{"version":3,"file":"pocketbase.cjs.js","sources":["../src/ClientResponseError.ts","../src/stores/utils/jwt.ts","../src/stores/utils/cookie.ts","../src/models/utils/BaseModel.ts","../src/models/Record.ts","../src/models/Admin.ts","../src/stores/LocalAuthStore.ts","../src/stores/BaseAuthStore.ts","../src/models/utils/ListResult.ts","../src/services/utils/BaseService.ts","../src/services/utils/CrudService.ts","../src/services/utils/BaseCrudService.ts","../src/models/utils/SchemaField.ts","../src/models/View.ts","../src/models/ExternalAuth.ts","../src/models/Collection.ts","../src/models/ViewRecord.ts","../src/models/LogRequest.ts","../src/services/ViewService.ts","../src/services/SettingsService.ts","../src/services/AdminService.ts","../src/services/RecordService.ts","../src/services/CollectionService.ts","../src/services/LogService.ts","../src/services/RealtimeService.ts","../src/services/HealthService.ts","../src/Client.ts"],"sourcesContent":["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport default class ClientResponseError extends Error {\n    url: string                = '';\n    status: number             = 0;\n    data: {[key: string]: any} = {};\n    isAbort:  boolean          = false;\n    originalError: any         = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (!(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (errData !== null && typeof errData === 'object') {\n            this.url    = typeof errData.url === 'string' ? errData.url : '';\n            this.status = typeof errData.status === 'number' ? errData.status : 0;\n            this.data   = errData.data !== null && typeof errData.data === 'object' ? errData.data : {};\n        }\n\n        if (typeof DOMException !== 'undefined' && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.data?.message;\n        if (!this.message) {\n            if (this.isAbort) {\n                this.message = 'The request was autocancelled. More info you could find in https://github.com/pocketbase/js-sdk#auto-cancellation.';\n            } else if (this.originalError?.cause?.message?.includes(\"ECONNREFUSED ::1\")) {\n                this.message = 'Failed to connect to the PocketBase server. Try replacing the SDK url from localhost to 127.0.0.1 (https://github.com/pocketbase/js-sdk/issues/21).';\n            } else {\n                this.message = 'Something went wrong while processing your request.';\n            }\n        }\n    }\n\n    // Make a POJO's copy of the current error class instance.\n    // @see https://github.com/vuex-orm/vuex-orm/issues/255\n    toJSON () {\n        return { ...this };\n    }\n}\n","let atobPolyfill: Function;\nif (typeof atob === 'function') {\n    atobPolyfill = atob\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) ?\n            (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n            0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(atobPolyfill(token.split('.')[1]).split('').map(function (c: string) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            }).join(''));\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {\n        }\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || (payload.exp - expirationThreshold) > (Date.now() / 1000))\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions{\n    decode?: (val: string) => string,\n}\n\n/**\n* Parses the given cookie header string into an object\n* The object has the various cookies as keys(names) => values\n*/\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any }  {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== 'string') {\n        return result;\n    }\n\n    const opt    = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n};\n\nexport interface SerializeOptions{\n    encode?:   (val: string | number | boolean) => string,\n    maxAge?:   number,\n    domain?:   string,\n    path?:     string,\n    expires?:  Date,\n    httpOnly?: boolean,\n    secure?:   boolean,\n    priority?: string,\n    sameSite?: boolean|string,\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(name: string, val: string, options?: SerializeOptions): string {\n    const opt    = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n\n    let result = name + '=' + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n\n        result += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n\n        result += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n\n        result += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError('option expires is invalid');\n        }\n\n        result += '; Expires=' + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += '; HttpOnly';\n    }\n\n    if (opt.secure) {\n        result += '; Secure';\n    }\n\n    if (opt.priority) {\n        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                result += '; Priority=Low';\n                break;\n            case 'medium':\n                result += '; Priority=Medium';\n                break;\n            case 'high':\n                result += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += '; SameSite=Strict';\n                break;\n            case 'lax':\n                result += '; SameSite=Lax';\n                break;\n            case 'strict':\n                result += '; SameSite=Strict';\n                break;\n            case 'none':\n                result += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return result;\n};\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf('%') !== -1\n        ? decodeURIComponent(val)\n        : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return (\n        Object.prototype.toString.call(val) === '[object Date]' ||\n        val instanceof Date\n    );\n}\n","export default abstract class BaseModel {\n    [key: string]: any,\n\n    id!:      string;\n    created!: string;\n    updated!: string;\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    /**\n     * Loads `data` into the current model.\n     */\n    load(data: { [key: string]: any }) {\n        for (const [key, value] of Object.entries(data)) {\n            this[key] = value;\n        }\n\n        // normalize known fields\n        this.id      = typeof data.id      !== 'undefined' ? data.id      : '';\n        this.created = typeof data.created !== 'undefined' ? data.created : '';\n        this.updated = typeof data.updated !== 'undefined' ? data.updated : '';\n    }\n\n    /**\n     * Returns whether the current loaded data represent a stored db record.\n     */\n    get isNew(): boolean {\n        return !this.id;\n    }\n\n    /**\n     * Creates a deep clone of the current model.\n     */\n    clone(): BaseModel {\n        const clone = typeof structuredClone === 'function' ?\n            structuredClone(this) : JSON.parse(JSON.stringify(this));\n\n        return new (this.constructor as any)(clone);\n    }\n\n    /**\n     * Exports all model properties as a new plain object.\n     */\n    export(): { [key: string]: any } {\n        return Object.assign({}, this);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Record extends BaseModel {\n    collectionId!:   string;\n    collectionName!: string;\n    expand!:         {[key: string]: Record|Array<Record>};\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        // normalize common fields\n        this.collectionId   = typeof data.collectionId   === 'string' ? data.collectionId   : '';\n        this.collectionName = typeof data.collectionName === 'string' ? data.collectionName : '';\n\n        // normalize expand items\n        this.loadExpand(data.expand);\n    }\n\n    /**\n     * Loads the provided expand items and recursively normalizes each\n     * item to a `Record|Array<Record>`.\n     */\n    private loadExpand(expand: { [key: string]: any }) {\n        expand = expand || {};\n        this.expand = {};\n\n        for (const key in expand) {\n            if (Array.isArray(expand[key])) {\n                this.expand[key] = expand[key].map((data: any) => new Record(data || {}));\n            } else {\n                this.expand[key] = new Record(expand[key] || {});\n            }\n        }\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Admin extends BaseModel {\n    avatar!: number;\n    email!:  string;\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.avatar = typeof data.avatar === 'number' ? data.avatar : 0;\n        this.email  = typeof data.email  === 'string' ? data.email  : '';\n    }\n}\n","import BaseAuthStore from '@/stores/BaseAuthStore';\nimport Record        from '@/models/Record';\nimport Admin         from '@/models/Admin';\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport default class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || '';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): Record|Admin|null {\n        const data = this._storageGet(this.storageKey) || {};\n\n        if (\n            data === null ||\n            typeof data !== 'object' ||\n            data.model === null ||\n            typeof data.model !== 'object'\n        ) {\n            return null;\n        }\n\n        // admins don't have `collectionId` prop\n        if (typeof data.model?.collectionId === 'undefined') {\n            return new Admin(data.model);\n        }\n\n        return new Record(data.model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model: Record|Admin|null) {\n        this._storageSet(this.storageKey, {\n            'token': token,\n            'model': model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || '';\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) { // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== 'string') {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from '@/stores/utils/cookie';\nimport { isTokenExpired, getTokenPayload } from '@/stores/utils/jwt';\nimport Record  from '@/models/Record';\nimport Admin from '@/models/Admin';\n\nexport type OnStoreChangeFunc = (token: string, model: Record|Admin|null) => void;\n\nconst defaultCookieKey = 'pb_auth';\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport default abstract class BaseAuthStore {\n    protected baseToken: string = '';\n    protected baseModel: Record|Admin|null = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): Record|Admin|null {\n        return this.baseModel;\n    }\n\n    /**\n     * Loosely checks if the store has valid token (aka. existing and unexpired exp claim).\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model: Record|Admin|null): void {\n        this.baseToken = token || '';\n\n        // normalize the model instance\n        if (model !== null && typeof model === 'object') {\n            this.baseModel = typeof (model as any).collectionId !== 'undefined' ?\n                new Record(model) : new Admin(model);\n        } else {\n            this.baseModel = null;\n        }\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = '';\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     *\n     * NB! This function doesn't validate the token or its data.\n     * Usually this isn't a concern if you are interacting only with the\n     * PocketBase API because it has the proper server-side security checks in place,\n     * but if you are using the store `isValid` state for permission controls\n     * in a node server (eg. SSR), then it is recommended to call `authRefresh()`\n     * after loading the cookie to ensure an up-to-date token and model state.\n     * For example:\n     *\n     * ```js\n     * pb.authStore.loadFromCookie(\"cookie string...\");\n     *\n     * try {\n     *     // get an up-to-date auth store state by veryfing and refreshing the loaded auth model (if any)\n     *     pb.authStore.isValid && await pb.collection('users').authRefresh();\n     * } catch (_) {\n     *     // clear the auth store on failed refresh\n     *     pb.authStore.clear();\n     * }\n     * ```\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || '')[key] || '';\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== 'object' || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || '', data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure:   true,\n            sameSite: true,\n            httpOnly: true,\n            path:     \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date('1970-01-01');\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model?.export() || null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength = typeof Blob !== 'undefined' ?\n            (new Blob([result])).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = {id: rawData?.model?.id, email: rawData?.model?.email};\n            if (this.model instanceof Record) {\n                rawData.model.username     = this.model.username;\n                rawData.model.verified     = this.model.verified;\n                rawData.model.collectionId = this.model.collectionId;\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i];    // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        }\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import BaseModel from './BaseModel';\n\nexport default class ListResult<M = BaseModel> {\n    page!:       number;\n    perPage!:    number;\n    totalItems!: number;\n    totalPages!: number;\n    items!:      Array<M>;\n\n    constructor(\n        page: number,\n        perPage: number,\n        totalItems: number,\n        totalPages: number,\n        items: Array<M>,\n    ) {\n        this.page       = page > 0 ? page : 1;\n        this.perPage    = perPage >= 0 ? perPage : 0;\n        this.totalItems = totalItems >= 0 ? totalItems : 0;\n        this.totalPages = totalPages >= 0 ? totalPages : 0;\n        this.items      = items || [];\n    }\n}\n","import Client from '@/Client';\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport default abstract class BaseService {\n    readonly client: Client\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import ListResult      from '@/models/utils/ListResult';\nimport BaseModel       from '@/models/utils/BaseModel';\nimport BaseCrudService from '@/services/utils/BaseCrudService';\nimport {\n    BaseQueryParams,\n    ListQueryParams\n} from '@/services/utils/QueryParams';\n\nexport default abstract class CrudService<M extends BaseModel> extends BaseCrudService<M> {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getFullList<T = M>(batch = 200, queryParams: ListQueryParams = {}): Promise<Array<T>> {\n        return this._getFullList<T>(this.baseCrudPath, batch, queryParams);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getList<T = M>(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<T>> {\n        return this._getList<T>(this.baseCrudPath, page, perPage, queryParams);\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter })` and returns the\n     * first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    getFirstListItem<T = M>(filter: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._getFirstListItem<T>(this.baseCrudPath, filter, queryParams);\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getOne<T = M>(id: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._getOne<T>(this.baseCrudPath, id, queryParams);\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    create<T = M>(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._create<T>(this.baseCrudPath, bodyParams, queryParams);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    update<T = M>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this._update<T>(this.baseCrudPath, id, bodyParams, queryParams);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this._delete(this.baseCrudPath, id, queryParams);\n    }\n}\n","import BaseModel           from '@/models/utils/BaseModel';\nimport ListResult          from '@/models/utils/ListResult';\nimport BaseService         from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\nimport {\n    BaseQueryParams,\n    ListQueryParams\n} from '@/services/utils/QueryParams';\n\n// @todo since there is no longer need of SubCrudService consider merging with CrudService in v0.9+\nexport default abstract class BaseCrudService<M extends BaseModel> extends BaseService {\n    /**\n     * Response data decoder.\n     */\n    abstract decode(data: { [key: string]: any }): M\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(basePath: string, batchSize = 100, queryParams: ListQueryParams = {}): Promise<Array<T>> {\n        var result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this._getList(basePath, page, batchSize, queryParams).then((list) => {\n                const castedList = (list as any as ListResult<T>);\n                const items = castedList.items;\n                const totalItems = castedList.totalItems;\n\n                result = result.concat(items);\n\n                if (items.length && totalItems > result.length) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n\n    /**\n     * Returns paginated items list.\n     */\n    protected _getList<T = M>(basePath: string, page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<T>> {\n        queryParams = Object.assign({\n            'page': page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send(basePath, {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<T> = [];\n            if (responseData?.items) {\n                responseData.items = responseData.items || [];\n                for (const item of responseData.items) {\n                    items.push(this.decode(item) as any as T);\n                }\n            }\n\n            return new ListResult<T>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     */\n    protected _getOne<T = M>(basePath: string, id: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Returns the first found item by a list filter.\n     *\n     * Internally it calls `_getList(basePath, 1, 1, { filter })` and returns its\n     * first item.\n     *\n     * For consistency with `_getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    protected _getFirstListItem<T = M>(basePath: string, filter: string, queryParams: BaseQueryParams = {}): Promise<T> {\n        queryParams = Object.assign({\n            'filter': filter,\n            '$cancelKey': 'one_by_filter_' + basePath + \"_\" + filter,\n        }, queryParams);\n\n        return this._getList<T>(basePath, 1, 1, queryParams)\n            .then((result) => {\n                if (!result?.items?.length) {\n                    throw new ClientResponseError({\n                        status: 404,\n                        data: {\n                            code: 404,\n                            message: \"The requested resource wasn't found.\",\n                            data: {},\n                        },\n                    });\n                }\n\n                return result.items[0];\n            });\n    }\n\n    /**\n     * Creates a new item.\n     */\n    protected _create<T = M>(basePath: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath, {\n            'method': 'POST',\n            'params': queryParams,\n            'body': bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     */\n    protected _update<T = M>(basePath: string, id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body': bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    protected _delete(basePath: string, id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n}\n","export default class SchemaField {\n    id!:       string;\n    name!:     string;\n    type!:     string;\n    system!:   boolean;\n    required!: boolean;\n    unique!:   boolean;\n    options!:  { [key: string]: any };\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    /**\n     * Loads `data` into the field.\n     */\n    load(data: { [key: string]: any }) {\n        this.id       = typeof data.id !== 'undefined' ? data.id : '';\n        this.name     = typeof data.name !== 'undefined' ? data.name : '';\n        this.type     = typeof data.type !== 'undefined' ? data.type : 'text';\n        this.system   = !!data.system;\n        this.required = !!data.required;\n        this.unique   = !!data.unique;\n        this.options  = typeof data.options === 'object' && data.options !== null ? data.options : {};\n    }\n}\n","import BaseModel   from '@/models/utils/BaseModel';\nimport SchemaField from '@/models/utils/SchemaField';\n\nexport default class View extends BaseModel {\n    name!:       string;\n    schema!:     Array<SchemaField>;\n    listRule!:   null|string;\n    sql!: string\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.name  = typeof data.name === 'string' ? data.name : '';\n\n        // rules\n        this.listRule = typeof data.listRule   === 'string' ? data.listRule   : null;\n\n        // sql \n        this.sql = typeof data.sql === 'string' ? data.sql : '';\n\n        // schema\n        data.schema = Array.isArray(data.schema) ? data.schema : [];\n        this.schema = [];\n        for (let field of data.schema) {\n            this.schema.push(new SchemaField(field));\n        }\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class ExternalAuth extends BaseModel {\n    recordId!:     string;\n    collectionId!: string;\n    provider!:     string;\n    providerId!:   string;\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.recordId     = typeof data.recordId     === 'string' ? data.recordId     : '';\n        this.collectionId = typeof data.collectionId === 'string' ? data.collectionId : '';\n        this.provider     = typeof data.provider     === 'string' ? data.provider     : '';\n        this.providerId   = typeof data.providerId   === 'string' ? data.providerId   : '';\n    }\n}\n","import BaseModel   from '@/models/utils/BaseModel';\nimport SchemaField from '@/models/utils/SchemaField';\n\nexport default class Collection extends BaseModel {\n    name!:       string;\n    type!:       string;\n    schema!:     Array<SchemaField>;\n    system!:     boolean;\n    listRule!:   null|string;\n    viewRule!:   null|string;\n    createRule!: null|string;\n    updateRule!: null|string;\n    deleteRule!: null|string;\n    options!:    {[key:string]: any};\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.system    = !!data.system;\n        this.name      = typeof data.name    === 'string'    ? data.name    : '';\n        this.type      = typeof data.type    === 'string'    ? data.type    : 'base';\n        this.options   = typeof data.options !== 'undefined' ? data.options : {};\n\n        // rules\n        this.listRule   = typeof data.listRule   === 'string' ? data.listRule   : null;\n        this.viewRule   = typeof data.viewRule   === 'string' ? data.viewRule   : null;\n        this.createRule = typeof data.createRule === 'string' ? data.createRule : null;\n        this.updateRule = typeof data.updateRule === 'string' ? data.updateRule : null;\n        this.deleteRule = typeof data.deleteRule === 'string' ? data.deleteRule : null;\n\n        // schema\n        data.schema = Array.isArray(data.schema) ? data.schema : [];\n        this.schema = [];\n        for (let field of data.schema) {\n            this.schema.push(new SchemaField(field));\n        }\n    }\n\n    /**\n     * Checks if the current model is \"base\" collection.\n     */\n    get isBase(): boolean {\n        return this.type === 'base';\n    }\n\n    /**\n     * Checks if the current model is \"auth\" collection.\n     */\n    get isAuth(): boolean {\n        return this.type === 'auth';\n    }\n\n    /**\n     * Checks if the current model is \"single\" collection.\n     */\n    get isSingle(): boolean {\n        return this.type === 'single';\n    }\n}\n","\nexport default class ViewRecord {\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    [key: string]: any,\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        for (const [key, value] of Object.entries(data)) {\n            this[key] = value;\n        }\n    }\n    clone(): ViewRecord {\n        return new (this.constructor as any)(JSON.parse(JSON.stringify(this)));\n    }\n\n    /**\n     * Exports all model properties as a new plain object.\n     */\n    export(): { [key: string]: any } {\n        return Object.assign({}, this);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class LogRequest extends BaseModel {\n    url!:       string;\n    method!:    string;\n    status!:    number;\n    auth!:      string;\n    remoteIp!:  string;\n    userIp!:    string;\n    referer!:   string;\n    userAgent!: string;\n    meta!:      { [key: string]: any };\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        // fallback to the ip field for backward compatibility\n        data.remoteIp = data.remoteIp || data.ip;\n\n        this.url       = typeof data.url       === 'string' ? data.url       : '';\n        this.method    = typeof data.method    === 'string' ? data.method    : 'GET';\n        this.status    = typeof data.status    === 'number' ? data.status    : 200;\n        this.auth      = typeof data.auth      === 'string' ? data.auth      : 'guest';\n        this.remoteIp  = typeof data.remoteIp  === 'string' ? data.remoteIp  : '';\n        this.userIp    = typeof data.userIp    === 'string' ? data.userIp    : '';\n        this.referer   = typeof data.referer   === 'string' ? data.referer   : '';\n        this.userAgent = typeof data.userAgent === 'string' ? data.userAgent : '';\n        this.meta      = typeof data.meta === 'object' && data.meta !== null ? data.meta : {};\n    }\n}\n","\nimport CrudService from '@/services/utils/CrudService';\nimport View  from '@/models/View';\nimport { ViewRecord } from '..';\n\nexport default class Views extends CrudService<View> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): View {\n        return new View(data);\n    }\n\n    /**\n     * @inheritdoc */\n\n    get baseCrudPath(): string {\n        return '/api/views';\n    }\n\n    getRecordsFullList(viewName: string, batchSize = 100, queryParams = {}): Promise<Array<ViewRecord>> {\n        const basePath= `${this.baseCrudPath}/${viewName}/records`\n        var result: Array<ViewRecord> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this.getRecordsList(basePath, page, batchSize, queryParams).then((list) => {\n                console.log(list);\n                \n                const castedList = (list as ViewRecordListResult);\n                const items = castedList.items;\n                const totalItems = castedList.totalItems;\n\n                result = result.concat(items);\n\n                if (items.length && totalItems > result.length) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n\n    /**\n     * Returns paginated items list.\n     */\n    getRecordsList(viewName: string, page = 1, perPage = 30, queryParams = {}): Promise<ViewRecordListResult> {\n        const basePath= `${this.baseCrudPath}/${viewName}/records`\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send(basePath, {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<ViewRecord> = [];\n            if (responseData?.items) {\n                responseData.items = responseData.items || [];\n                for (const item of responseData.items) {\n                    items.push(new ViewRecord(item));\n                }\n            }\n\n            return new ViewRecordListResult(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n}\n\n class ViewRecordListResult{\n    page!: number;\n    perPage!: number;\n    totalItems!: number;\n    totalPages!: number;\n    items!: Array<ViewRecord>;\n\n    constructor(\n        page: number,\n        perPage: number,\n        totalItems: number,\n        totalPages: number,\n        items: Array<ViewRecord>,\n    ) {\n        this.page = page > 0 ? page : 1;\n        this.perPage = perPage >= 0 ? perPage : 0;\n        this.totalItems = totalItems >= 0 ? totalItems : 0;\n        this.totalPages = totalPages >= 0 ? totalPages : 0;\n        this.items = items || [];\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport default class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     */\n    getAll(queryParams: BaseQueryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Bulk updates app settings.\n     */\n    update(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Performs a S3 storage connection test.\n     */\n    testS3(queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return this.client.send('/api/settings/test/s3', {\n            'method': 'POST',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     */\n    testEmail(toEmail: string, emailTemplate: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'email':    toEmail,\n            'template': emailTemplate,\n        };\n\n        return this.client.send('/api/settings/test/email', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import Admin               from '@/models/Admin';\nimport CrudService         from '@/services/utils/CrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface AdminAuthResponse {\n    [key: string]: any;\n\n    token: string;\n    admin: Admin;\n}\n\nexport default class AdminService extends CrudService<Admin> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Admin {\n        return new Admin(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/admins';\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Admin>(id: string, bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<T> {\n        return super.update<Admin>(id, bodyParams, queryParams).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === item?.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token': responseData?.token || '',\n            'admin': admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authWithPassword(\n        email: string,\n        password: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<AdminAuthResponse> {\n        bodyParams = Object.assign({\n            'identity': email,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authRefresh(bodyParams = {}, queryParams: BaseQueryParams = {}): Promise<AdminAuthResponse> {\n        return this.client.send(this.baseCrudPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import Client              from '@/Client';\nimport Record              from '@/models/Record';\nimport ExternalAuth        from '@/models/ExternalAuth';\nimport ListResult          from '@/models/utils/ListResult';\nimport CrudService         from '@/services/utils/CrudService';\nimport { UnsubscribeFunc } from '@/services/RealtimeService';\nimport {\n    BaseQueryParams,\n    RecordQueryParams,\n    RecordListQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface RecordAuthResponse<T = Record> {\n    record: T;\n    token:  string;\n    meta?:  {[key: string]: any};\n}\n\nexport interface AuthProviderInfo {\n    name:                string;\n    state:               string;\n    codeVerifier:        string;\n    codeChallenge:       string;\n    codeChallengeMethod: string;\n    authUrl:             string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword:    boolean;\n    authProviders:    Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = Record> {\n    action: string;\n    record: T;\n}\n\nexport default class RecordService extends CrudService<Record> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    decode<T = Record>(data: { [key: string]: any }): T {\n        return new Record(data) as any as T;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + '/records';\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return '/api/collections/' + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * @deprecated Use subscribe(recordId, callback) instead.\n     *\n     * Subscribe to the realtime changes of a single record in the collection.\n     */\n    async subscribeOne<T = Record>(recordId: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc> {\n        console.warn(\"PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subscribe(recordId, callback).\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + recordId, callback);\n    }\n\n    /**\n     * @deprecated This form of subscribe is deprecated. Please use `subscribe(\"*\", callback)`.\n     */\n    async subscribe<T = Record>(callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = Record>(topic: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    async subscribe<T = Record>(\n        topicOrCallback: string|((data: RecordSubscription<T>) => void),\n        callback?: (data: RecordSubscription<T>) => void\n    ): Promise<UnsubscribeFunc> {\n        if (typeof topicOrCallback === 'function') {\n            console.warn(\"PocketBase: subscribe(callback) is deprecated. Please replace it with subscribe('*', callback).\");\n            return this.client.realtime.subscribe(this.collectionIdOrName, topicOrCallback);\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        if (topicOrCallback === \"\") {\n            throw new Error(\"Missing topic.\");\n        }\n\n        let topic = this.collectionIdOrName;\n        if (topicOrCallback !== \"*\") {\n            topic += ('/' + topicOrCallback);\n        }\n\n        return this.client.realtime.subscribe(topic, callback)\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe wildcard topic\n        if (topic === \"*\") {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName);\n        }\n\n        // unsubscribe recordId topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + topic);\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Crud handers\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     */\n    getFullList<T = Record>(batch = 200, queryParams: RecordListQueryParams = {}): Promise<Array<T>> {\n        return super.getFullList<T>(batch, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getList<T = Record>(page = 1, perPage = 30, queryParams: RecordListQueryParams = {}): Promise<ListResult<T>> {\n        return super.getList<T>(page, perPage, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getFirstListItem<T = Record>(filter: string, queryParams: RecordListQueryParams = {}): Promise<T> {\n        return super.getFirstListItem<T>(filter, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    getOne<T = Record>(id: string, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.getOne<T>(id, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    create<T = Record>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.create<T>(bodyParams, queryParams);\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Record>(id: string, bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<T> {\n        return super.update<Record>(id, bodyParams, queryParams).then((item) => {\n            if (\n                typeof this.client.authStore.model?.collectionId !== 'undefined' && // is record auth\n                this.client.authStore.model?.id === item?.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams: BaseQueryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            if (\n                success &&\n                typeof this.client.authStore.model?.collectionId !== 'undefined' && // is record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = Record>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token':  responseData?.token || '',\n            'record': record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     */\n    listAuthMethods(queryParams: BaseQueryParams = {}): Promise<AuthMethodsList> {\n        return this.client.send(this.baseCollectionPath + '/auth-methods', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            return Object.assign({}, responseData, {\n                // normalize common fields\n                'usernamePassword': !!responseData?.usernamePassword,\n                'emailPassword':    !!responseData?.emailPassword,\n                'authProviders':    Array.isArray(responseData?.authProviders) ? responseData?.authProviders : [],\n            });\n        });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     */\n    authWithPassword<T = Record>(\n        usernameOrEmail: string,\n        password: string,\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'identity': usernameOrEmail,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     */\n    authWithOAuth2<T = Record>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData = {},\n        bodyParams = {},\n        queryParams: RecordQueryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'provider':     provider,\n            'code':         code,\n            'codeVerifier': codeVerifier,\n            'redirectUrl':  redirectUrl,\n            'createData':  createData,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-oauth2', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     */\n    authRefresh<T = Record>(bodyParams = {}, queryParams: RecordQueryParams = {}): Promise<RecordAuthResponse<T>> {\n        return this.client.send(this.baseCollectionPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     */\n    requestVerification(\n        email: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     */\n    confirmVerification(\n        verificationToken: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': verificationToken,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     */\n    requestEmailChange(\n        newEmail: string,\n        bodyParams = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'newEmail': newEmail,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     */\n    confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyParams  = {},\n        queryParams: BaseQueryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': emailChangeToken,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     */\n    listExternalAuths(\n        recordId: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<Array<ExternalAuth>> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => {\n            const items: Array<ExternalAuth> = [];\n\n            if (Array.isArray(responseData)) {\n                for (const item of responseData) {\n                    items.push(new ExternalAuth(item));\n                }\n            }\n\n            return items;\n        });\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     */\n    unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        queryParams: BaseQueryParams = {}\n    ): Promise<boolean> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths/' + encodeURIComponent(provider), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n}\n","import Collection          from '@/models/Collection';\nimport CrudService         from '@/services/utils/CrudService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport default class CollectionService extends CrudService<Collection> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Collection {\n        return new Collection(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/collections';\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     */\n    async import(\n        collections: Array<Collection>,\n        deleteMissing: boolean = false,\n        queryParams: BaseQueryParams = {}\n    ): Promise<true> {\n        return this.client.send(this.baseCrudPath + '/import', {\n            'method': 'PUT',\n            'params': queryParams,\n            'body': {\n                'collections':  collections,\n                'deleteMissing': deleteMissing,\n            }\n        }).then(() => true);\n    }\n}\n","import LogRequest  from '@/models/LogRequest';\nimport ListResult  from '@/models/utils/ListResult';\nimport BaseService from '@/services/utils/BaseService';\nimport {\n    BaseQueryParams,\n    ListQueryParams,\n    LogStatsQueryParams,\n} from '@/services/utils/QueryParams';\n\nexport interface HourlyStats {\n    total: number;\n    date:  string;\n}\n\nexport default class LogService extends BaseService {\n    /**\n     * Returns paginated logged requests list.\n     */\n    getRequestsList(page = 1, perPage = 30, queryParams: ListQueryParams = {}): Promise<ListResult<LogRequest>> {\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send('/api/logs/requests', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<LogRequest> = [];\n            if (responseData?.items) {\n                responseData.items = responseData?.items || [];\n                for (const item of responseData.items) {\n                    items.push(new LogRequest(item));\n                }\n            }\n\n            return new ListResult<LogRequest>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns a single logged request by its id.\n     */\n    getRequest(id: string, queryParams: BaseQueryParams = {}): Promise<LogRequest> {\n        return this.client.send('/api/logs/requests/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => new LogRequest(responseData));\n    }\n\n    /**\n     * Returns request logs statistics.\n     */\n    getRequestsStats(queryParams: LogStatsQueryParams = {}): Promise<Array<HourlyStats>> {\n        return this.client.send('/api/logs/requests/stats', {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => responseData);\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\n\ninterface promiseCallbacks {\n    resolve: Function\n    reject: Function\n}\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport default class RealtimeService extends BaseService {\n    private clientId: string = \"\";\n    private eventSource: EventSource | null = null;\n    private subscriptions: { [key: string]: Array<EventListener> } = {};\n    private lastSentTopics: Array<string> = [];\n    private connectTimeoutId: any;\n    private maxConnectTimeout: number = 15000;\n    private reconnectTimeoutId: any;\n    private reconnectAttempts: number = 0;\n    private maxReconnectAttempts: number = Infinity;\n    private predefinedReconnectIntervals: Array<number> = [\n        200, 300, 500, 1000, 1200, 1500, 2000,\n    ];\n    private pendingConnects: Array<promiseCallbacks> = [];\n\n    /**\n     * Returns whether the realtime connection has been established.\n     */\n    get isConnected(): boolean {\n        return !!this.eventSource && !!this.clientId && !this.pendingConnects.length;\n    }\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(topic: string, callback: (data: any) => void): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error('topic must be set.')\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = (e as MessageEvent);\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = [];\n        }\n        this.subscriptions[topic].push(listener);\n\n        if (!this.isConnected) {\n            // initialize sse connection\n            await this.connect();\n        } else if (this.subscriptions[topic].length === 1) {\n            // send the updated subscriptions (if it is the first for the topic)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource?.addEventListener(topic, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (!this.hasSubscriptionListeners(topic)) {\n            return; // already unsubscribed\n        }\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all topic listeners\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(topicPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let topic in this.subscriptions) {\n            if (!topic.startsWith(topicPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(topic: string, listener: EventListener): Promise<void> {\n        if (!Array.isArray(this.subscriptions[topic]) || !this.subscriptions[topic].length) {\n            return; // already unsubscribed\n        }\n\n        let exist = false;\n        for (let i = this.subscriptions[topic].length - 1; i >= 0; i--) {\n            if (this.subscriptions[topic][i] !== listener) {\n                continue;\n            }\n\n            exist = true;                           // has at least one matching listener\n            delete this.subscriptions[topic][i];    // removes the function reference\n            this.subscriptions[topic].splice(i, 1); // reindex the array\n            this.eventSource?.removeEventListener(topic, listener);\n        }\n        if (!exist) {\n            return;\n        }\n\n        // remove the topic from the subscriptions list if there are no other listeners\n        if (!this.subscriptions[topic].length) {\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(topicToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified topic\n        if (topicToCheck) {\n            return !!this.subscriptions[topicToCheck]?.length;\n        }\n\n        // check for at least one non-empty topic\n        for (let topic in this.subscriptions) {\n            if (!!this.subscriptions[topic]?.length) {\n                return true\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<void> {\n        if (!this.clientId) {\n            return; // no client/subscriber\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        this.lastSentTopics = this.getNonEmptySubscriptionTopics();\n\n        return this.client.send('/api/realtime', {\n            'method': 'POST',\n            'body': {\n                'clientId': this.clientId,\n                'subscriptions': this.lastSentTopics,\n            },\n            'params': {\n                '$cancelKey': \"realtime_\" + this.clientId,\n            },\n        }).catch((err) => {\n            if (err?.isAbort) {\n                return; // silently ignore aborted pending requests\n            }\n            throw err;\n        });\n    }\n\n    private getNonEmptySubscriptionTopics(): Array<string> {\n        const result : Array<string> = [];\n\n        for (let topic in this.subscriptions) {\n            if (this.subscriptions[topic].length) {\n                result.push(topic);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.addEventListener(topic, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.removeEventListener(topic, listener);\n            }\n        }\n    }\n\n    private async connect(): Promise<void> {\n        if (this.reconnectAttempts > 0)  {\n            // immediately resolve the promise to avoid indefinitely\n            // blocking the client during reconnection\n            return;\n        }\n\n        return new Promise((resolve, reject) => {\n            this.pendingConnects.push({ resolve, reject });\n\n            if (this.pendingConnects.length > 1) {\n                // all promises will be resolved once the connection is established\n                return;\n            }\n\n            this.initConnect();\n        })\n    }\n\n    private initConnect() {\n        this.disconnect(true);\n\n        // wait up to 15s for connect\n        clearTimeout(this.connectTimeoutId);\n        this.connectTimeoutId = setTimeout(() => {\n            this.connectErrorHandler(new Error(\"EventSource connect took too long.\"));\n        }, this.maxConnectTimeout);\n\n        this.eventSource = new EventSource(this.client.buildUrl('/api/realtime'))\n\n        this.eventSource.onerror = (_) => {\n            this.connectErrorHandler(new Error(\"Failed to establish realtime connection.\"));\n        };\n\n        this.eventSource.addEventListener('PB_CONNECT', (e) => {\n            const msgEvent = (e as MessageEvent);\n            this.clientId = msgEvent?.lastEventId;\n\n            this.submitSubscriptions()\n            .then(async () => {\n                let retries = 3;\n                while (this.hasUnsentSubscriptions() && retries > 0) {\n                    retries--;\n                    // resubscribe to ensure that the latest topics are submitted\n                    //\n                    // This is needed because missed topics could happen on reconnect\n                    // if after the pending sent `submitSubscriptions()` call another `subscribe()`\n                    // was made before the submit was able to complete.\n                    await this.submitSubscriptions();\n                }\n            }).then(() => {\n                for (let p of this.pendingConnects) {\n                    p.resolve();\n                }\n\n                // reset connect meta\n                this.pendingConnects = [];\n                this.reconnectAttempts = 0;\n                clearTimeout(this.reconnectTimeoutId);\n                clearTimeout(this.connectTimeoutId);\n            }).catch((err) => {\n                this.clientId = \"\";\n                this.connectErrorHandler(err);\n            });\n        });\n    }\n\n    private hasUnsentSubscriptions(): boolean {\n        const latestTopics = this.getNonEmptySubscriptionTopics();\n        if (latestTopics.length != this.lastSentTopics.length) {\n            return true;\n        }\n\n        for (const t of latestTopics) {\n            if (!this.lastSentTopics.includes(t)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private connectErrorHandler(err: any) {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n\n        if (\n            // wasn't previously connected -> direct reject\n            (!this.clientId && !this.reconnectAttempts) ||\n            // was previously connected but the max reconnection limit has been reached\n            this.reconnectAttempts > this.maxReconnectAttempts\n        ) {\n            for (let p of this.pendingConnects) {\n                p.reject(new ClientResponseError(err));\n            }\n            this.disconnect();\n            return;\n        }\n\n        // otherwise -> reconnect in the background\n        this.disconnect(true);\n        const timeout = this.predefinedReconnectIntervals[this.reconnectAttempts] || this.predefinedReconnectIntervals[this.predefinedReconnectIntervals.length - 1];\n        this.reconnectAttempts++;\n        this.reconnectTimeoutId = setTimeout(() => {\n            this.initConnect();\n        }, timeout);\n    }\n\n    private disconnect(fromReconnect = false): void {\n        clearTimeout(this.connectTimeoutId);\n        clearTimeout(this.reconnectTimeoutId);\n        this.removeAllSubscriptionListeners();\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n\n        if (!fromReconnect) {\n            this.reconnectAttempts = 0;\n\n            // reject any remaining connect promises\n            const err = new ClientResponseError(new Error(\"Realtime disconnected.\"));\n            for (let p of this.pendingConnects) {\n                p.reject(err);\n            }\n            this.pendingConnects = [];\n        }\n    }\n}\n","import BaseService         from '@/services/utils/BaseService';\nimport { BaseQueryParams } from '@/services/utils/QueryParams';\n\nexport interface healthCheckResponse {\n    code:    number;\n    message: string;\n}\n\nexport default class HealthService extends BaseService {\n    /**\n     * Checks the health status of the api.\n     */\n    check(queryParams: BaseQueryParams = {}): Promise<healthCheckResponse> {\n        return this.client.send('/api/health', {\n            'method': 'GET',\n            'params': queryParams,\n        });\n    }\n}\n","import ClientResponseError from '@/ClientResponseError';\nimport BaseAuthStore       from '@/stores/BaseAuthStore';\nimport LocalAuthStore      from '@/stores/LocalAuthStore';\nimport ViewService               from './services/ViewService';\nimport SettingsService     from '@/services/SettingsService';\nimport AdminService        from '@/services/AdminService';\nimport RecordService       from '@/services/RecordService';\nimport CollectionService   from '@/services/CollectionService';\nimport LogService          from '@/services/LogService';\nimport RealtimeService     from '@/services/RealtimeService';\nimport HealthService       from '@/services/HealthService';\nimport Record              from '@/models/Record';\nimport { FileQueryParams } from '@/services/utils/QueryParams';\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n    /**\n     * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n     */\n    baseUrl: string;\n\n    /**\n     * Hook that get triggered right before sending the fetch request,\n     * allowing you to inspect/modify the request config.\n     *\n     * Returns the new modified config that will be used to send the request.\n     *\n     * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n     *\n     * Example:\n     * ```js\n     * client.beforeSend = function (url, reqConfig) {\n     *     reqConfig.headers = Object.assign({}, reqConfig.headers, {\n     *         'X-Custom-Header': 'example',\n     *     });\n     *\n     *     return reqConfig;\n     * };\n     * ```\n     */\n    beforeSend?: (url: string, reqConfig: { [key: string]: any }) => { [key: string]: any };\n\n    /**\n     * Hook that get triggered after successfully sending the fetch request,\n     * allowing you to inspect/modify the response object and its parsed data.\n     *\n     * Returns the new Promise resolved `data` that will be returned to the client.\n     *\n     * Example:\n     * ```js\n     * client.afterSend = function (response, data) {\n     *     if (response.status != 200) {\n     *         throw new ClientResponseError({\n     *             url:      response.url,\n     *             status:   response.status,\n     *             data:     data,\n     *         });\n     *     }\n     *\n     *     return data;\n     * };\n     * ```\n     */\n    afterSend?: (response: Response, data: any) => any;\n\n    /**\n     * Optional language code (default to `en-US`) that will be sent\n     * with the requests to the server as `Accept-Language` header.\n     */\n    lang: string;\n\n    /**\n     * A replaceable instance of the local auth store service.\n     */\n    authStore: BaseAuthStore;\n\n    /**\n     * An instance of the service that handles the **Settings APIs**.\n     */\n    readonly settings: SettingsService;\n\n    /**\n     * An instance of the service that handles the **Admin APIs**.\n     */\n    readonly admins: AdminService;\n\n    /**\n     * An instance of the service that handles the **Collection APIs**.\n     */\n    readonly collections: CollectionService;\n\n    readonly views: ViewService;\n\n    /**\n     * An instance of the service that handles the **Record APIs**.\n     */\n\n    /**\n     * An instance of the service that handles the **Log APIs**.\n     */\n    readonly logs: LogService;\n\n    /**\n     * An instance of the service that handles the **Realtime APIs**.\n     */\n    readonly realtime: RealtimeService;\n\n    /**\n     * An instance of the service that handles the **Health APIs**.\n     */\n    readonly health: HealthService;\n\n    private cancelControllers: { [key: string]: AbortController } = {};\n    private recordServices: { [key: string]: RecordService } = {};\n    private enableAutoCancellation: boolean = true;\n\n    constructor(\n        baseUrl = '/',\n        authStore?: BaseAuthStore | null,\n        lang = 'en-US',\n    ) {\n        this.baseUrl   = baseUrl;\n        this.lang      = lang;\n        this.authStore = authStore || new LocalAuthStore();\n\n        // services\n        this.views = new ViewService(this);\n        this.admins      = new AdminService(this);\n        this.collections = new CollectionService(this);\n        this.logs        = new LogService(this);\n        this.settings    = new SettingsService(this);\n        this.realtime    = new RealtimeService(this);\n        this.health      = new HealthService(this);\n    }\n\n    /**\n     * Returns the RecordService associated to the specified collection.\n     *\n     * @param  {string} idOrName\n     * @return {RecordService}\n     */\n    collection(idOrName: string): RecordService {\n        if (!this.recordServices[idOrName]) {\n            this.recordServices[idOrName] = new RecordService(this, idOrName);\n        }\n\n        return this.recordServices[idOrName];\n    }\n\n    /**\n     * Globally enable or disable auto cancellation for pending duplicated requests.\n     */\n    autoCancellation(enable: boolean): Client {\n        this.enableAutoCancellation = !!enable;\n\n        return this;\n    }\n\n    /**\n     * Cancels single request by its cancellation key.\n     */\n    cancelRequest(cancelKey: string): Client {\n        if (this.cancelControllers[cancelKey]) {\n            this.cancelControllers[cancelKey].abort();\n            delete this.cancelControllers[cancelKey];\n        }\n\n        return this;\n    }\n\n    /**\n     * Cancels all pending requests.\n     */\n    cancelAllRequests(): Client {\n        for (let k in this.cancelControllers) {\n            this.cancelControllers[k].abort();\n        }\n\n        this.cancelControllers = {};\n\n        return this;\n    }\n\n    /**\n     * Sends an api http request.\n     */\n    async send(path: string, reqConfig: { [key: string]: any }): Promise<any> {\n        let config = Object.assign({ method: 'GET' } as { [key: string]: any }, reqConfig);\n\n        // serialize the body if needed and set the correct content type\n        // note1: for FormData body the Content-Type header should be skipped\n        // note2: we are checking the constructor name because FormData is not available natively in node\n        if (config.body && config.body.constructor.name !== 'FormData') {\n            if (typeof config.body !== 'string') {\n                config.body = JSON.stringify(config.body);\n            }\n\n            // add the json header (if not already)\n            if (typeof config?.headers?.['Content-Type'] === 'undefined') {\n                config.headers = Object.assign({}, config.headers, {\n                    'Content-Type': 'application/json',\n                });\n            }\n        }\n\n        // add Accept-Language header (if not already)\n        if (typeof config?.headers?.['Accept-Language'] === 'undefined') {\n            config.headers = Object.assign({}, config.headers, {\n                'Accept-Language': this.lang,\n            });\n        }\n\n        // check if Authorization header can be added\n        if (\n            // has stored token\n            this.authStore?.token &&\n            // auth header is not explicitly set\n            (typeof config?.headers?.Authorization === 'undefined')\n        ) {\n            config.headers = Object.assign({}, config.headers, {\n                'Authorization': this.authStore.token,\n            });\n        }\n\n        // handle auto cancelation for duplicated pending request\n        if (this.enableAutoCancellation && config.params?.$autoCancel !== false) {\n            const cancelKey = config.params?.$cancelKey || ((config.method || 'GET') + path);\n\n            // cancel previous pending requests\n            this.cancelRequest(cancelKey);\n\n            const controller = new AbortController();\n            this.cancelControllers[cancelKey] = controller;\n            config.signal = controller.signal;\n        }\n        // remove the special cancellation params from the other valid query params\n        delete config.params?.$autoCancel;\n        delete config.params?.$cancelKey;\n\n        // build url + path\n        let url = this.buildUrl(path);\n\n        // serialize the query parameters\n        if (typeof config.params !== 'undefined') {\n            const query = this.serializeQueryParams(config.params)\n            if (query) {\n                url += (url.includes('?') ? '&' : '?') + query;\n            }\n            delete config.params;\n        }\n\n        if (this.beforeSend) {\n            config = Object.assign({}, this.beforeSend(url, config));\n        }\n\n        // send the request\n        return fetch(url, config)\n            .then(async (response) => {\n                let data : any = {};\n\n                try {\n                    data = await response.json();\n                } catch (_) {\n                    // all api responses are expected to return json\n                    // with the exception of the realtime event and 204\n                }\n\n                if (this.afterSend) {\n                    data = this.afterSend(response, data);\n                }\n\n                if (response.status >= 400) {\n                    throw new ClientResponseError({\n                        url:      response.url,\n                        status:   response.status,\n                        data:     data,\n                    });\n                }\n\n                return data;\n            }).catch((err) => {\n                // wrap to normalize all errors\n                throw new ClientResponseError(err);\n            });\n    }\n\n    /**\n     * Builds and returns an absolute record file url for the provided filename.\n     */\n    getFileUrl(record: Record, filename: string, queryParams: FileQueryParams = {}): string {\n        const parts = [];\n        parts.push(\"api\")\n        parts.push(\"files\")\n        parts.push(encodeURIComponent(record.collectionId || record.collectionName))\n        parts.push(encodeURIComponent(record.id))\n        parts.push(encodeURIComponent(filename))\n\n        let result = this.buildUrl(parts.join('/'));\n\n        if (Object.keys(queryParams).length) {\n            const params = new URLSearchParams(queryParams);\n            result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n        }\n\n        return result\n    }\n\n    /**\n     * Builds a full client url by safely concatenating the provided path.\n     */\n    buildUrl(path: string): string {\n        let url = this.baseUrl + (this.baseUrl.endsWith('/') ? '' : '/');\n        if (path) {\n            url += (path.startsWith('/') ? path.substring(1) : path);\n        }\n        return url;\n    }\n\n    /**\n     * Serializes the provided query parameters into a query string.\n     */\n    private serializeQueryParams(params: {[key: string]: any}): string {\n        const result: Array<string> = [];\n        for (const key in params) {\n            if (params[key] === null) {\n                // skip null query params\n                continue;\n            }\n\n            const value = params[key];\n            const encodedKey = encodeURIComponent(key);\n\n            if (Array.isArray(value)) {\n                // \"repeat\" array params\n                for (const v of value) {\n                    result.push(encodedKey + \"=\" + encodeURIComponent(v));\n                }\n            } else if (value instanceof Date) {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n            } else if (typeof value !== null && typeof value === 'object') {\n                result.push(encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value)));\n            } else {\n                result.push(encodedKey + \"=\" + encodeURIComponent(value));\n            }\n        }\n\n        return result.join('&');\n    }\n}\n"],"names":["atobPolyfill","ClientResponseError","_super","errData","_this","this","call","url","status","data","isAbort","originalError","Object","setPrototypeOf","prototype","DOMException","name","message","_a","_d","_c","_b","cause","includes","__extends","toJSON","__assign","Error","fieldContentRegExp","cookieSerialize","val","options","opt","assign","encode","defaultEncode","test","TypeError","value","result","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","isDate","toString","Date","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","defaultDecode","indexOf","decodeURIComponent","encodeURIComponent","getTokenPayload","token","encodedPayload","split","map","c","charCodeAt","slice","join","JSON","parse","e","atob","input","str","String","replace","length","bs","buffer","bc","idx","output","charAt","fromCharCode","BaseModel","load","_i","entries","key","id","created","updated","defineProperty","get","clone","structuredClone","stringify","constructor","export","Record","collectionId","collectionName","loadExpand","expand","Array","isArray","Admin","avatar","email","LocalAuthStore","storageKey","storageFallback","_storageGet","model","save","_storageSet","clear","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","isTokenExpired","expirationThreshold","payload","keys","exp","now","triggerChange","loadFromCookie","cookie","rawData","cookieParse","decode","index","eqIdx","endIdx","lastIndexOf","trim","undefined","_","exportToCookie","defaultOptions","resultLength","Blob","size","username","verified","onChange","callback","fireImmediately","push","i","splice","ListResult","page","perPage","totalItems","totalPages","items","BaseService","client","CrudService","getFullList","batch","queryParams","_getFullList","baseCrudPath","getList","_getList","getFirstListItem","filter","_getFirstListItem","getOne","_getOne","create","bodyParams","_create","update","_update","delete","_delete","BaseCrudService","basePath","batchSize","request","__awaiter","then","list","castedList","concat","send","method","params","responseData","item","$cancelKey","code","body","SchemaField","type","system","required","unique","View","listRule","sql","schema","field","ExternalAuth","recordId","provider","providerId","Collection","viewRule","createRule","updateRule","deleteRule","ViewRecord","LogRequest","remoteIp","ip","auth","userIp","referer","userAgent","meta","Views","getRecordsFullList","viewName","getRecordsList","console","log","ViewRecordListResult","SettingsService","getAll","testS3","testEmail","toEmail","emailTemplate","template","AdminService","authStore","success","authResponse","admin","authWithPassword","password","identity","bind","authRefresh","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","RecordService","collectionIdOrName","baseCollectionPath","subscribeOne","warn","realtime","subscribe","topicOrCallback","topic","unsubscribe","unsubscribeByPrefix","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2","codeVerifier","redirectUrl","createData","requestVerification","confirmVerification","verificationToken","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","responseData_1","unlinkExternalAuth","CollectionService","import","collections","deleteMissing","LogService","getRequestsList","getRequest","getRequestsStats","RealtimeService","apply","arguments","clientId","eventSource","subscriptions","lastSentTopics","maxConnectTimeout","reconnectAttempts","maxReconnectAttempts","Infinity","predefinedReconnectIntervals","pendingConnects","listener","msgEvent","isConnected","connect","sent","submitSubscriptions","addEventListener","unsubscribeByTopicAndListener","hasSubscriptionListeners","removeEventListener","disconnect","topicPrefix","hasAtleastOneTopic","startsWith","exist","topicToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionTopics","catch","err","removeAllSubscriptionListeners","Promise","resolve","reject","initConnect","clearTimeout","connectTimeoutId","setTimeout","connectErrorHandler","EventSource","buildUrl","onerror","lastEventId","retries","hasUnsentSubscriptions","reconnectTimeoutId","latestTopics","latestTopics_1","t","timeout","fromReconnect","close","HealthService","check","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","views","ViewService","admins","logs","settings","health","collection","idOrName","autoCancellation","enable","cancelRequest","cancelKey","abort","cancelAllRequests","k","reqConfig","config","headers","Authorization","_e","$autoCancel","_f","controller","AbortController","signal","_g","_h","query","serializeQueryParams","beforeSend","fetch","response","json","afterSend","getFileUrl","filename","parts","URLSearchParams","endsWith","substring","encodedKey","value_1","v","toISOString"],"mappings":"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"}