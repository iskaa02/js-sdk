{"version":3,"file":"pocketbase.es.js","sources":["../src/ClientResponseError.ts","../src/stores/utils/jwt.ts","../src/stores/utils/cookie.ts","../src/models/utils/BaseModel.ts","../src/models/Record.ts","../src/models/Admin.ts","../src/stores/BaseAuthStore.ts","../src/stores/LocalAuthStore.ts","../src/models/utils/ListResult.ts","../src/services/utils/BaseService.ts","../src/services/utils/CrudService.ts","../src/services/utils/BaseCrudService.ts","../src/models/utils/SchemaField.ts","../src/models/View.ts","../src/services/ViewService.ts","../src/services/SettingsService.ts","../src/services/AdminService.ts","../src/models/ExternalAuth.ts","../src/services/RecordService.ts","../src/models/Collection.ts","../src/services/CollectionService.ts","../src/models/LogRequest.ts","../src/services/LogService.ts","../src/services/RealtimeService.ts","../src/Client.ts","../src/models/ViewRecord.ts"],"sourcesContent":["/**\n * ClientResponseError is a custom Error class that is intended to wrap\n * and normalize any error thrown by `Client.send()`.\n */\nexport default class ClientResponseError extends Error {\n    url: string                = '';\n    status: number             = 0;\n    data: {[key: string]: any} = {};\n    isAbort:  boolean          = false;\n    originalError: any         = null;\n\n    constructor(errData?: any) {\n        super(\"ClientResponseError\");\n\n        // Set the prototype explicitly.\n        // https://github.com/Microsoft/TypeScript-wiki/blob/main/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n        Object.setPrototypeOf(this, ClientResponseError.prototype);\n\n        if (!(errData instanceof ClientResponseError)) {\n            this.originalError = errData;\n        }\n\n        if (errData !== null && typeof errData === 'object') {\n            this.url    = typeof errData.url === 'string' ? errData.url : '';\n            this.status = typeof errData.status === 'number' ? errData.status : 0;\n            this.data   = errData.data !== null && typeof errData.data === 'object' ? errData.data : {};\n        }\n\n        if (typeof DOMException !== 'undefined' && errData instanceof DOMException) {\n            this.isAbort = true;\n        }\n\n        this.name = \"ClientResponseError \" + this.status;\n        this.message = this.data?.message;\n        if (!this.message) {\n            this.message = this.isAbort ?\n                'The request was autocancelled. More info you could find in https://github.com/pocketbase/js-sdk#auto-cancellation.' :\n                'Something went wrong while processing your request.';\n        }\n    }\n\n    // Make a POJO's copy of the current error class instance.\n    // @see https://github.com/vuex-orm/vuex-orm/issues/255\n    toJSON () {\n        return { ...this };\n    }\n}\n","let atobPolyfill: Function;\nif (typeof atob === 'function') {\n    atobPolyfill = atob\n} else {\n    /**\n     * The code was extracted from:\n     * https://github.com/davidchambers/Base64.js\n     */\n    atobPolyfill = (input: any) => {\n        const chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n        let str = String(input).replace(/=+$/, \"\");\n        if (str.length % 4 == 1) {\n            throw new Error(\"'atob' failed: The string to be decoded is not correctly encoded.\");\n        }\n\n        for (\n            // initialize result and counters\n            var bc = 0, bs, buffer, idx = 0, output = \"\";\n            // get next character\n            (buffer = str.charAt(idx++));\n            // character found in table? initialize bit storage and add its ascii value;\n            ~buffer &&\n            ((bs = bc % 4 ? (bs as any) * 64 + buffer : buffer),\n                // and if not first of each 4 characters,\n                // convert the first 8 bits to one ascii character\n                bc++ % 4) ?\n            (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6)))) :\n            0\n        ) {\n            // try to find character in table (0-63, not found => -1)\n            buffer = chars.indexOf(buffer);\n        }\n\n        return output;\n    };\n}\n\n/**\n * Returns JWT token's payload data.\n */\nexport function getTokenPayload(token: string): { [key: string]: any } {\n    if (token) {\n        try {\n            const encodedPayload = decodeURIComponent(atobPolyfill(token.split('.')[1]).split('').map(function (c: string) {\n                return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n            }).join(''));\n\n            return JSON.parse(encodedPayload) || {};\n        } catch (e) {\n        }\n    }\n\n    return {};\n}\n\n/**\n * Checks whether a JWT token is expired or not.\n * Tokens without `exp` payload key are considered valid.\n * Tokens with empty payload (eg. invalid token strings) are considered expired.\n *\n * @param token The token to check.\n * @param [expirationThreshold] Time in seconds that will be subtracted from the token `exp` property.\n */\nexport function isTokenExpired(token: string, expirationThreshold = 0): boolean {\n    let payload = getTokenPayload(token);\n\n    if (\n        Object.keys(payload).length > 0 &&\n        (!payload.exp || (payload.exp - expirationThreshold) > (Date.now() / 1000))\n    ) {\n        return false;\n    }\n\n    return true;\n}\n","/**\n * -------------------------------------------------------------------\n * Simple cookie parse and serialize utilities mostly based on the\n * node module https://github.com/jshttp/cookie.\n * -------------------------------------------------------------------\n */\n\n/**\n * RegExp to match field-content in RFC 7230 sec 3.2\n *\n * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]\n * field-vchar   = VCHAR / obs-text\n * obs-text      = %x80-FF\n */\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007e\\u0080-\\u00ff]+$/;\n\nexport interface ParseOptions{\n    decode?: (val: string) => string,\n}\n\n/**\n* Parses the given cookie header string into an object\n* The object has the various cookies as keys(names) => values\n*/\nexport function cookieParse(str: string, options?: ParseOptions): { [key: string]: any }  {\n    const result: { [key: string]: any } = {};\n\n    if (typeof str !== 'string') {\n        return result;\n    }\n\n    const opt    = Object.assign({}, options || {});\n    const decode = opt.decode || defaultDecode;\n\n    let index = 0;\n    while (index < str.length) {\n        const eqIdx = str.indexOf('=', index);\n\n        // no more cookie pairs\n        if (eqIdx === -1) {\n            break;\n        }\n\n        let endIdx = str.indexOf(';', index);\n\n        if (endIdx === -1) {\n            endIdx = str.length;\n        } else if (endIdx < eqIdx) {\n            // backtrack on prior semicolon\n            index = str.lastIndexOf(';', eqIdx - 1) + 1;\n            continue;\n        }\n\n        const key = str.slice(index, eqIdx).trim();\n\n        // only assign once\n        if (undefined === result[key]) {\n            let val = str.slice(eqIdx + 1, endIdx).trim();\n\n            // quoted values\n            if (val.charCodeAt(0) === 0x22) {\n                val = val.slice(1, -1);\n            }\n\n            try {\n                result[key] = decode(val);\n            } catch (_) {\n                result[key] = val; // no decoding\n            }\n        }\n\n        index = endIdx + 1;\n    }\n\n    return result;\n};\n\nexport interface SerializeOptions{\n    encode?:   (val: string | number | boolean) => string,\n    maxAge?:   number,\n    domain?:   string,\n    path?:     string,\n    expires?:  Date,\n    httpOnly?: boolean,\n    secure?:   boolean,\n    priority?: string,\n    sameSite?: boolean|string,\n}\n\n/**\n * Serialize data into a cookie header.\n *\n * Serialize the a name value pair into a cookie string suitable for\n * http headers. An optional options object specified cookie parameters.\n *\n * ```js\n * cookieSerialize('foo', 'bar', { httpOnly: true }) // \"foo=bar; httpOnly\"\n * ```\n */\nexport function cookieSerialize(name: string, val: string, options?: SerializeOptions): string {\n    const opt    = Object.assign({}, options || {});\n    const encode = opt.encode || defaultEncode;\n\n    if (!fieldContentRegExp.test(name)) {\n        throw new TypeError('argument name is invalid');\n    }\n\n    const value = encode(val);\n\n    if (value && !fieldContentRegExp.test(value)) {\n        throw new TypeError('argument val is invalid');\n    }\n\n    let result = name + '=' + value;\n\n    if (opt.maxAge != null) {\n        const maxAge = opt.maxAge - 0;\n\n        if (isNaN(maxAge) || !isFinite(maxAge)) {\n            throw new TypeError('option maxAge is invalid');\n        }\n\n        result += '; Max-Age=' + Math.floor(maxAge);\n    }\n\n    if (opt.domain) {\n        if (!fieldContentRegExp.test(opt.domain)) {\n            throw new TypeError('option domain is invalid');\n        }\n\n        result += '; Domain=' + opt.domain;\n    }\n\n    if (opt.path) {\n        if (!fieldContentRegExp.test(opt.path)) {\n            throw new TypeError('option path is invalid');\n        }\n\n        result += '; Path=' + opt.path;\n    }\n\n    if (opt.expires) {\n        if (!isDate(opt.expires) || isNaN(opt.expires.valueOf())) {\n            throw new TypeError('option expires is invalid');\n        }\n\n        result += '; Expires=' + opt.expires.toUTCString();\n    }\n\n    if (opt.httpOnly) {\n        result += '; HttpOnly';\n    }\n\n    if (opt.secure) {\n        result += '; Secure';\n    }\n\n    if (opt.priority) {\n        const priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;\n\n        switch (priority) {\n            case 'low':\n                result += '; Priority=Low';\n                break;\n            case 'medium':\n                result += '; Priority=Medium';\n                break;\n            case 'high':\n                result += '; Priority=High';\n                break;\n            default:\n                throw new TypeError('option priority is invalid');\n        }\n    }\n\n    if (opt.sameSite) {\n        const sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;\n\n        switch (sameSite) {\n            case true:\n                result += '; SameSite=Strict';\n                break;\n            case 'lax':\n                result += '; SameSite=Lax';\n                break;\n            case 'strict':\n                result += '; SameSite=Strict';\n                break;\n            case 'none':\n                result += '; SameSite=None';\n                break;\n            default:\n                throw new TypeError('option sameSite is invalid');\n        }\n    }\n\n    return result;\n};\n\n/**\n * Default URL-decode string value function.\n * Optimized to skip native call when no `%`.\n */\nfunction defaultDecode(val: string): string {\n    return val.indexOf('%') !== -1\n        ? decodeURIComponent(val)\n        : val;\n}\n\n/**\n * Default URL-encode value function.\n */\nfunction defaultEncode(val: string | number | boolean): string {\n    return encodeURIComponent(val);\n}\n\n/**\n * Determines if value is a Date.\n */\nfunction isDate(val: any): boolean {\n    return (\n        Object.prototype.toString.call(val) === '[object Date]' ||\n        val instanceof Date\n    );\n}\n","export default abstract class BaseModel {\n    [key: string]: any,\n\n    id!:      string;\n    created!: string;\n    updated!: string;\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    /**\n     * Loads `data` into the current model.\n     */\n    load(data: { [key: string]: any }) {\n        for (const [key, value] of Object.entries(data)) {\n            this[key] = value;\n        }\n\n        // normalize known fields\n        this.id      = typeof data.id      !== 'undefined' ? data.id      : '';\n        this.created = typeof data.created !== 'undefined' ? data.created : '';\n        this.updated = typeof data.updated !== 'undefined' ? data.updated : '';\n    }\n\n    /**\n     * Returns whether the current loaded data represent a stored db record.\n     */\n    get isNew(): boolean {\n        return !this.id;\n    }\n\n    /**\n     * Creates a seep clone of the current model.\n     */\n    clone(): BaseModel {\n        return new (this.constructor as any)(JSON.parse(JSON.stringify(this)));\n    }\n\n    /**\n     * Exports all model properties as a new plain object.\n     */\n    export(): { [key: string]: any } {\n        return Object.assign({}, this);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Record extends BaseModel {\n    collectionId!:   string;\n    collectionName!: string;\n    expand!:         {[key: string]: Record|Array<Record>};\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        // normalize common fields\n        this.collectionId   = typeof data.collectionId   === 'string' ? data.collectionId   : '';\n        this.collectionName = typeof data.collectionName === 'string' ? data.collectionName : '';\n        this.expand         = typeof data.expand === 'object' && data.expand !== null ? data.expand : {};\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class Admin extends BaseModel {\n    avatar!: number;\n    email!:  string;\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.avatar = typeof data.avatar === 'number' ? data.avatar : 0;\n        this.email  = typeof data.email  === 'string' ? data.email  : '';\n    }\n}\n","import { cookieParse, cookieSerialize, SerializeOptions } from '@/stores/utils/cookie';\nimport { isTokenExpired, getTokenPayload } from '@/stores/utils/jwt';\nimport Record  from '@/models/Record';\nimport Admin from '@/models/Admin';\n\nexport type OnStoreChangeFunc = (token: string, model: Record|Admin|null) => void;\n\nconst defaultCookieKey = 'pb_auth';\n\n/**\n * Base AuthStore class that is intended to be extended by all other\n * PocketBase AuthStore implementations.\n */\nexport default abstract class BaseAuthStore {\n    protected baseToken: string = '';\n    protected baseModel: Record|Admin|null = null;\n\n    private _onChangeCallbacks: Array<OnStoreChangeFunc> = [];\n\n    /**\n     * Retrieves the stored token (if any).\n     */\n    get token(): string {\n        return this.baseToken;\n    }\n\n    /**\n     * Retrieves the stored model data (if any).\n     */\n    get model(): Record|Admin|null {\n        return this.baseModel;\n    }\n\n    /**\n     * Checks if the store has valid (aka. existing and unexpired) token.\n     */\n    get isValid(): boolean {\n        return !isTokenExpired(this.token);\n    }\n\n    /**\n     * Saves the provided new token and model data in the auth store.\n     */\n    save(token: string, model: Record|Admin|null): void {\n        this.baseToken = token || '';\n\n        // normalize the model instance\n        if (model !== null && typeof model === 'object') {\n            this.baseModel = typeof (model as any).collectionId !== 'undefined' ?\n                new Record(model) : new Admin(model);\n        } else {\n            this.baseModel = null;\n        }\n\n        this.triggerChange();\n    }\n\n    /**\n     * Removes the stored token and model data form the auth store.\n     */\n    clear(): void {\n        this.baseToken = '';\n        this.baseModel = null;\n        this.triggerChange();\n    }\n\n    /**\n     * Parses the provided cookie string and updates the store state\n     * with the cookie's token and model data.\n     */\n    loadFromCookie(cookie: string, key = defaultCookieKey): void {\n        const rawData = cookieParse(cookie || '')[key] || '';\n\n        let data: { [key: string]: any } = {};\n        try {\n            data = JSON.parse(rawData);\n            // normalize\n            if (typeof data === null || typeof data !== 'object' || Array.isArray(data)) {\n                data = {};\n            }\n        } catch (_) {}\n\n        this.save(data.token || '', data.model || null);\n    }\n\n    /**\n     * Exports the current store state as cookie string.\n     *\n     * By default the following optional attributes are added:\n     * - Secure\n     * - HttpOnly\n     * - SameSite=Strict\n     * - Path=/\n     * - Expires={the token expiration date}\n     *\n     * NB! If the generated cookie exceeds 4096 bytes, this method will\n     * strip the model data to the bare minimum to try to fit within the\n     * recommended size in https://www.rfc-editor.org/rfc/rfc6265#section-6.1.\n     */\n    exportToCookie(options?: SerializeOptions, key = defaultCookieKey): string {\n        const defaultOptions: SerializeOptions = {\n            secure:   true,\n            sameSite: true,\n            httpOnly: true,\n            path:     \"/\",\n        };\n\n        // extract the token expiration date\n        const payload = getTokenPayload(this.token);\n        if (payload?.exp) {\n            defaultOptions.expires = new Date(payload.exp * 1000);\n        } else {\n            defaultOptions.expires = new Date('1970-01-01');\n        }\n\n        // merge with the user defined options\n        options = Object.assign({}, defaultOptions, options);\n\n        const rawData = {\n            token: this.token,\n            model: this.model?.export() || null,\n        };\n\n        let result = cookieSerialize(key, JSON.stringify(rawData), options);\n\n        const resultLength = typeof Blob !== 'undefined' ?\n            (new Blob([result])).size : result.length;\n\n        // strip down the model data to the bare minimum\n        if (rawData.model && resultLength > 4096) {\n            rawData.model = {id: rawData?.model?.id, email: rawData?.model?.email};\n            if (this.model instanceof Record) {\n                rawData.model.username     = this.model.username;\n                rawData.model.verified     = this.model.verified;\n                rawData.model.collectionId = this.model.collectionId;\n            }\n            result = cookieSerialize(key, JSON.stringify(rawData), options);\n        }\n\n        return result;\n    }\n\n    /**\n     * Register a callback function that will be called on store change.\n     *\n     * You can set the `fireImmediately` argument to true in order to invoke\n     * the provided callback right after registration.\n     *\n     * Returns a removal function that you could call to \"unsubscribe\" from the changes.\n     */\n    onChange(callback: OnStoreChangeFunc, fireImmediately = false): () => void {\n        this._onChangeCallbacks.push(callback);\n\n        if (fireImmediately) {\n            callback(this.token, this.model);\n        }\n\n        return () => {\n            for (let i = this._onChangeCallbacks.length - 1; i >= 0; i--) {\n                if (this._onChangeCallbacks[i] == callback) {\n                    delete this._onChangeCallbacks[i];    // removes the function reference\n                    this._onChangeCallbacks.splice(i, 1); // reindex the array\n                    return;\n                }\n            }\n        }\n    }\n\n    protected triggerChange(): void {\n        for (const callback of this._onChangeCallbacks) {\n            callback && callback(this.token, this.model);\n        }\n    }\n}\n","import BaseAuthStore from '@/stores/BaseAuthStore';\nimport Record        from '@/models/Record';\nimport Admin         from '@/models/Admin';\n\n/**\n * The default token store for browsers with auto fallback\n * to runtime/memory if local storage is undefined (eg. in node env).\n */\nexport default class LocalAuthStore extends BaseAuthStore {\n    private storageFallback: { [key: string]: any } = {};\n    private storageKey: string\n\n    constructor(storageKey = \"pocketbase_auth\") {\n        super();\n\n        this.storageKey = storageKey;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get token(): string {\n        const data = this._storageGet(this.storageKey) || {};\n\n        return data.token || '';\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get model(): Record|Admin|null {\n        const data = this._storageGet(this.storageKey) || {};\n\n        if (\n            data === null ||\n            typeof data !== 'object' ||\n            data.model === null ||\n            typeof data.model !== 'object'\n        ) {\n            return null;\n        }\n\n        // admins don't have `collectionId` prop\n        if (typeof data.model?.collectionId === 'undefined') {\n            return new Admin(data.model);\n        }\n\n        return new Record(data.model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    save(token: string, model: Record|Admin|null) {\n        this._storageSet(this.storageKey, {\n            'token': token,\n            'model': model,\n        });\n\n        super.save(token, model);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    clear() {\n        this._storageRemove(this.storageKey);\n\n        super.clear();\n    }\n\n    // ---------------------------------------------------------------\n    // Internal helpers:\n    // ---------------------------------------------------------------\n\n    /**\n     * Retrieves `key` from the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageGet(key: string): any {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            const rawValue = window.localStorage.getItem(key) || '';\n            try {\n                return JSON.parse(rawValue);\n            } catch (e) { // not a json\n                return rawValue;\n            }\n        }\n\n        // fallback\n        return this.storageFallback[key];\n    }\n\n    /**\n     * Stores a new data in the browser's local storage\n     * (or runtime/memory if local storage is undefined).\n     */\n    private _storageSet(key: string, value: any) {\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            // store in local storage\n            let normalizedVal = value;\n            if (typeof value !== 'string') {\n                normalizedVal = JSON.stringify(value);\n            }\n            window.localStorage.setItem(key, normalizedVal);\n        } else {\n            // store in fallback\n            this.storageFallback[key] = value;\n        }\n    }\n\n    /**\n     * Removes `key` from the browser's local storage and the runtime/memory.\n     */\n    private _storageRemove(key: string) {\n        // delete from local storage\n        if (typeof window !== 'undefined' && window?.localStorage) {\n            window.localStorage?.removeItem(key);\n        }\n\n        // delete from fallback\n        delete this.storageFallback[key];\n    }\n}\n","import BaseModel from './BaseModel';\n\nexport default class ListResult<M = BaseModel> {\n    page!:       number;\n    perPage!:    number;\n    totalItems!: number;\n    totalPages!: number;\n    items!:      Array<M>;\n\n    constructor(\n        page: number,\n        perPage: number,\n        totalItems: number,\n        totalPages: number,\n        items: Array<M>,\n    ) {\n        this.page       = page > 0 ? page : 1;\n        this.perPage    = perPage >= 0 ? perPage : 0;\n        this.totalItems = totalItems >= 0 ? totalItems : 0;\n        this.totalPages = totalPages >= 0 ? totalPages : 0;\n        this.items      = items || [];\n    }\n}\n","import Client from '@/Client';\n\n/**\n * BaseService class that should be inherited from all API services.\n */\nexport default abstract class BaseService {\n    readonly client: Client\n\n    constructor(client: Client) {\n        this.client = client;\n    }\n}\n","import ListResult          from '@/models/utils/ListResult';\nimport BaseModel           from '@/models/utils/BaseModel';\nimport BaseCrudService     from '@/services/utils/BaseCrudService';\n\nexport default abstract class CrudService<M extends BaseModel> extends BaseCrudService<M> {\n    /**\n     * Base path for the crud actions (without trailing slash, eg. '/admins').\n     */\n    abstract get baseCrudPath(): string\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getFullList<T = M>(batch = 200, queryParams = {}): Promise<Array<T>> {\n        return this._getFullList<T>(this.baseCrudPath, batch, queryParams);\n    }\n\n    /**\n     * Returns paginated items list.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getList<T = M>(page = 1, perPage = 30, queryParams = {}): Promise<ListResult<T>> {\n        return this._getList<T>(this.baseCrudPath, page, perPage, queryParams);\n    }\n\n    /**\n     * Returns the first found item by the specified filter.\n     *\n     * Internally it calls `getList(1, 1, { filter })` and returns the\n     * first found item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     *\n     * For consistency with `getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    getFirstListItem<T = M>(filter: string, queryParams = {}): Promise<T> {\n        return this._getFirstListItem<T>(this.baseCrudPath, filter, queryParams);\n    }\n\n    /**\n     * Returns single item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    getOne<T = M>(id: string, queryParams = {}): Promise<T> {\n        return this._getOne<T>(this.baseCrudPath, id, queryParams);\n    }\n\n    /**\n     * Creates a new item.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    create<T = M>(bodyParams = {}, queryParams = {}): Promise<T> {\n        return this._create<T>(this.baseCrudPath, bodyParams, queryParams);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     *\n     * You can use the generic T to supply a wrapper type of the crud model.\n     */\n    update<T = M>(id: string, bodyParams = {}, queryParams = {}): Promise<T> {\n        return this._update<T>(this.baseCrudPath, id, bodyParams, queryParams);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    delete(id: string, queryParams = {}): Promise<boolean> {\n        return this._delete(this.baseCrudPath, id, queryParams);\n    }\n}\n","import BaseModel           from '@/models/utils/BaseModel';\nimport ListResult          from '@/models/utils/ListResult';\nimport BaseService         from '@/services/utils/BaseService';\nimport ClientResponseError from '@/ClientResponseError';\n\n// @todo since there is no longer need of SubCrudService consider merging with CrudService in v0.9+\nexport default abstract class BaseCrudService<M extends BaseModel> extends BaseService {\n    /**\n     * Response data decoder.\n     */\n    abstract decode(data: { [key: string]: any }): M\n\n    /**\n     * Returns a promise with all list items batch fetched at once.\n     */\n    protected _getFullList<T = M>(basePath: string, batchSize = 100, queryParams = {}): Promise<Array<T>> {\n        var result: Array<T> = [];\n\n        let request = async (page: number): Promise<Array<any>> => {\n            return this._getList(basePath, page, batchSize, queryParams).then((list) => {\n                const castedList = (list as any as ListResult<T>);\n                const items = castedList.items;\n                const totalItems = castedList.totalItems;\n\n                result = result.concat(items);\n\n                if (items.length && totalItems > result.length) {\n                    return request(page + 1);\n                }\n\n                return result;\n            });\n        }\n\n        return request(1);\n    }\n\n    /**\n     * Returns paginated items list.\n     */\n    protected _getList<T = M>(basePath: string, page = 1, perPage = 30, queryParams = {}): Promise<ListResult<T>> {\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send(basePath, {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<T> = [];\n            if (responseData?.items) {\n                responseData.items = responseData.items || [];\n                for (const item of responseData.items) {\n                    items.push(this.decode(item) as any as T);\n                }\n            }\n\n            return new ListResult<T>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns single item by its id.\n     */\n    protected _getOne<T = M>(basePath: string, id: string, queryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Returns the first found item by a list filter.\n     *\n     * Internally it calls `_getList(basePath, 1, 1, { filter })` and returns its\n     * first item.\n     *\n     * For consistency with `_getOne`, this method will throw a 404\n     * ClientResponseError if no item was found.\n     */\n    protected _getFirstListItem<T = M>(basePath: string, filter: string, queryParams = {}): Promise<T> {\n        queryParams = Object.assign({\n            'filter': filter,\n            '$cancelKey': 'one_by_filter_' + basePath + \"_\" + filter,\n        }, queryParams);\n\n        return this._getList<T>(basePath, 1, 1, queryParams)\n            .then((result) => {\n                if (!result?.items?.length) {\n                    throw new ClientResponseError({\n                        status: 404,\n                        data: {\n                            code:    404,\n                            message: \"The requested resource wasn't found.\",\n                            data:    {},\n                        },\n                    });\n                }\n\n                return result.items[0];\n            });\n    }\n\n    /**\n     * Creates a new item.\n     */\n    protected _create<T = M>(basePath: string, bodyParams = {}, queryParams = {}): Promise<T> {\n        return this.client.send(basePath, {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Updates an existing item by its id.\n     */\n    protected _update<T = M>(basePath: string, id: string, bodyParams = {}, queryParams = {}): Promise<T> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData: any) => this.decode(responseData) as any as T);\n    }\n\n    /**\n     * Deletes an existing item by its id.\n     */\n    protected _delete(basePath: string, id: string, queryParams = {}): Promise<boolean> {\n        return this.client.send(basePath + '/' + encodeURIComponent(id), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n}\n","export default class SchemaField {\n    id!:       string;\n    name!:     string;\n    type!:     string;\n    system!:   boolean;\n    required!: boolean;\n    unique!:   boolean;\n    options!:  { [key: string]: any };\n\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    /**\n     * Loads `data` into the field.\n     */\n    load(data: { [key: string]: any }) {\n        this.id       = typeof data.id !== 'undefined' ? data.id : '';\n        this.name     = typeof data.name !== 'undefined' ? data.name : '';\n        this.type     = typeof data.type !== 'undefined' ? data.type : 'text';\n        this.system   = !!data.system;\n        this.required = !!data.required;\n        this.unique   = !!data.unique;\n        this.options  = typeof data.options === 'object' && data.options !== null ? data.options : {};\n    }\n}\n","import BaseModel from \"@/models/utils/BaseModel\";\nimport SchemaField from \"@/models/utils/SchemaField\";\n\nexport default class ViewService extends BaseModel {\n  name!: string;\n  schema!: Array<SchemaField>;\n  listRule!: null | string;\n  sql!: string;\n\n  /**\n   * @inheritdoc\n   */\n  load(data: { [key: string]: any }) {\n    super.load(data);\n\n    this.name = typeof data.name === \"string\" ? data.name : \"\";\n\n    // rules\n    this.listRule = typeof data.listRule === \"string\" ? data.listRule : null;\n\n    // sql\n    this.sql = typeof data.sql === \"string\" ? data.sql : \"\";\n\n    // schema\n    data.schema = Array.isArray(data.schema) ? data.schema : [];\n    this.schema = [];\n    for (let field of data.schema) {\n      this.schema.push(new SchemaField(field));\n    }\n  }\n}\n","import CrudService from \"@/services/utils/CrudService\";\nimport ViewService from \"@/models/View\";\nimport { ViewRecord } from \"..\";\n\nexport default class Views extends CrudService<ViewService> {\n  /**\n   * @inheritdoc\n   */\n  decode(data: { [key: string]: any }): ViewService {\n    return new ViewService(data);\n  }\n\n  /**\n   * @inheritdoc */\n  get baseCrudPath(): string {\n    return \"/api/admins\";\n  }\n\n  getRecordsFullList(\n    viewName: string,\n    batchSize = 100,\n    queryParams = {}\n  ): Promise<Array<ViewRecord>> {\n    const basePath = `${this.baseCrudPath}/${viewName}/records`;\n    var result: Array<ViewRecord> = [];\n\n    let request = async (page: number): Promise<Array<any>> => {\n      return this.getRecordsList(basePath, page, batchSize, queryParams).then(\n        (list) => {\n          console.log(list);\n\n          const castedList = list as ViewRecordListResult;\n          const items = castedList.items;\n          const totalItems = castedList.totalItems;\n\n          result = result.concat(items);\n\n          if (items.length && totalItems > result.length) {\n            return request(page + 1);\n          }\n\n          return result;\n        }\n      );\n    };\n\n    return request(1);\n  }\n\n  /**\n   * Returns paginated items list.\n   */\n  getRecordsList(\n    viewName: string,\n    page = 1,\n    perPage = 30,\n    queryParams = {}\n  ): Promise<ViewRecordListResult> {\n    const basePath = `${this.baseCrudPath}/${viewName}/records`;\n    queryParams = Object.assign(\n      {\n        page: page,\n        perPage: perPage,\n      },\n      queryParams\n    );\n\n    return this.client\n      .send(basePath, {\n        method: \"GET\",\n        params: queryParams,\n      })\n      .then((responseData: any) => {\n        const items: Array<ViewRecord> = [];\n        if (responseData?.items) {\n          responseData.items = responseData.items || [];\n          for (const item of responseData.items) {\n            items.push(new ViewRecord(item));\n          }\n        }\n\n        return new ViewRecordListResult(\n          responseData?.page || 1,\n          responseData?.perPage || 0,\n          responseData?.totalItems || 0,\n          responseData?.totalPages || 0,\n          items\n        );\n      });\n  }\n}\n\nclass ViewRecordListResult {\n  page!: number;\n  perPage!: number;\n  totalItems!: number;\n  totalPages!: number;\n  items!: Array<ViewRecord>;\n\n  constructor(\n    page: number,\n    perPage: number,\n    totalItems: number,\n    totalPages: number,\n    items: Array<ViewRecord>\n  ) {\n    this.page = page > 0 ? page : 1;\n    this.perPage = perPage >= 0 ? perPage : 0;\n    this.totalItems = totalItems >= 0 ? totalItems : 0;\n    this.totalPages = totalPages >= 0 ? totalPages : 0;\n    this.items = items || [];\n  }\n}\n","import BaseService from '@/services/utils/BaseService';\n\nexport default class SettingsService extends BaseService {\n    /**\n     * Fetch all available app settings.\n     */\n    getAll(queryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Bulk updates app settings.\n     */\n    update(bodyParams = {}, queryParams = {}): Promise<{ [key: string]: any }> {\n        return this.client.send('/api/settings', {\n            'method': 'PATCH',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((responseData) => responseData || {});\n    }\n\n    /**\n     * Performs a S3 storage connection test.\n     */\n    testS3(queryParams = {}): Promise<boolean> {\n        return this.client.send('/api/settings/test/s3', {\n            'method': 'POST',\n            'params': queryParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends a test email.\n     *\n     * The possible `emailTemplate` values are:\n     * - verification\n     * - password-reset\n     * - email-change\n     */\n    testEmail(toEmail: string, emailTemplate: string, queryParams = {}): Promise<boolean> {\n        const bodyParams = {\n            'email':    toEmail,\n            'template': emailTemplate,\n        };\n\n        return this.client.send('/api/settings/test/email', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import CrudService from '@/services/utils/CrudService';\nimport Admin       from '@/models/Admin';\n\nexport type AdminAuthResponse = {\n    [key: string]: any,\n    token: string,\n    admin: Admin,\n}\n\nexport default class AdminService extends CrudService<Admin> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Admin {\n        return new Admin(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/admins';\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Admin>(id: string, bodyParams = {}, queryParams = {}): Promise<T> {\n        return super.update<Admin>(id, bodyParams, queryParams).then((item) => {\n            // update the store state if the updated item id matches with the stored model\n            if (\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === item?.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            // clear the store state if the deleted item id matches with the stored model\n            if (\n                success &&\n                this.client.authStore.model &&\n                typeof this.client.authStore.model?.collectionId === 'undefined' && // is not record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful authorize response.\n     */\n    protected authResponse(responseData: any): AdminAuthResponse {\n        const admin = this.decode(responseData?.admin || {});\n\n        if (responseData?.token && responseData?.admin) {\n            this.client.authStore.save(responseData.token, admin);\n        }\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token': responseData?.token || '',\n            'admin': admin,\n        });\n    }\n\n    /**\n     * Authenticate an admin account with its email and password\n     * and returns a new admin token and data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authWithPassword(\n        email: string,\n        password: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<AdminAuthResponse> {\n        bodyParams = Object.assign({\n            'identity': email,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n            'headers': {\n                'Authorization': '',\n            },\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Refreshes the current admin authenticated instance and\n     * returns a new token and admin data.\n     *\n     * On success this method automatically updates the client's AuthStore data.\n     */\n    authRefresh(bodyParams = {}, queryParams = {}): Promise<AdminAuthResponse> {\n        return this.client.send(this.baseCrudPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(this.authResponse.bind(this));\n    }\n\n    /**\n     * Sends admin password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms admin password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCrudPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class ExternalAuth extends BaseModel {\n    recordId!:     string;\n    collectionId!: string;\n    provider!:     string;\n    providerId!:   string;\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.recordId     = typeof data.recordId     === 'string' ? data.recordId     : '';\n        this.collectionId = typeof data.collectionId === 'string' ? data.collectionId : '';\n        this.provider     = typeof data.provider     === 'string' ? data.provider     : '';\n        this.providerId   = typeof data.providerId   === 'string' ? data.providerId   : '';\n    }\n}\n","import Client              from '@/Client';\nimport CrudService         from '@/services/utils/CrudService';\nimport { UnsubscribeFunc } from '@/services/RealtimeService';\nimport Record              from '@/models/Record';\nimport ExternalAuth        from '@/models/ExternalAuth';\n\nexport interface RecordAuthResponse<T = Record> {\n    token:  string;\n    record: T;\n    meta?: {[key: string]: any};\n}\n\nexport interface AuthProviderInfo {\n    name:                string;\n    state:               string;\n    codeVerifier:        string;\n    codeChallenge:       string;\n    codeChallengeMethod: string;\n    authUrl:             string;\n}\n\nexport interface AuthMethodsList {\n    usernamePassword: boolean;\n    emailPassword:    boolean;\n    authProviders:    Array<AuthProviderInfo>;\n}\n\nexport interface RecordSubscription<T = Record> {\n    action: string;\n    record: T;\n}\n\nexport default class RecordService extends CrudService<Record> {\n    readonly collectionIdOrName: string;\n\n    constructor(client: Client, collectionIdOrName: string) {\n        super(client);\n\n        this.collectionIdOrName = collectionIdOrName;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    decode<T = Record>(data: { [key: string]: any }): T {\n        return new Record(data) as any as T;\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return this.baseCollectionPath + '/records';\n    }\n\n    /**\n     * Returns the current collection service base path.\n     */\n    get baseCollectionPath(): string {\n        return '/api/collections/' + encodeURIComponent(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Realtime handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * @deprecated Use subscribe(recordId, callback) instead.\n     *\n     * Subscribe to the realtime changes of a single record in the collection.\n     */\n    async subscribeOne<T = Record>(recordId: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc> {\n        console.warn(\"PocketBase: subscribeOne(recordId, callback) is deprecated. Please replace it with subsribe(recordId, callback).\");\n        return this.client.realtime.subscribe(this.collectionIdOrName + \"/\" + recordId, callback);\n    }\n\n    /**\n     * @deprecated This form of subscribe is deprecated. Please use `subscribe(\"*\", callback)`.\n     */\n    async subscribe<T = Record>(callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    /**\n     * Subscribe to realtime changes to the specified topic (\"*\" or record id).\n     *\n     * If `topic` is the wildcard \"*\", then this method will subscribe to\n     * any record changes in the collection.\n     *\n     * If `topic` is a record id, then this method will subscribe only\n     * to changes of the specified record id.\n     *\n     * It's OK to subscribe multiple times to the same topic.\n     * You can use the returned `UnsubscribeFunc` to remove only a single subscription.\n     * Or use `unsubscribe(topic)` if you want to remove all subscriptions attached to the topic.\n     */\n    async subscribe<T = Record>(topic: string, callback: (data: RecordSubscription<T>) => void): Promise<UnsubscribeFunc>\n\n    async subscribe<T = Record>(\n        topicOrCallback: string|((data: RecordSubscription<T>) => void),\n        callback?: (data: RecordSubscription<T>) => void\n    ): Promise<UnsubscribeFunc> {\n        if (typeof topicOrCallback === 'function') {\n            console.warn(\"PocketBase: subscribe(callback) is deprecated. Please replace it with subsribe('*', callback).\");\n            return this.client.realtime.subscribe(this.collectionIdOrName, topicOrCallback);\n        }\n\n        if (!callback) {\n            throw new Error(\"Missing subscription callback.\");\n        }\n\n        if (topicOrCallback === \"\") {\n            throw new Error(\"Missing topic.\");\n        }\n\n        let topic = this.collectionIdOrName;\n        if (topicOrCallback !== \"*\") {\n            topic += ('/' + topicOrCallback);\n        }\n\n        return this.client.realtime.subscribe(topic, callback)\n    }\n\n    /**\n     * Unsubscribe from all subscriptions of the specified topic\n     * (\"*\" or record id).\n     *\n     * If `topic` is not set, then this method will unsubscribe from\n     * all subscriptions associated to the current collection.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        // unsubscribe wildcard topic\n        if (topic === \"*\") {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName);\n        }\n\n        // unsubscribe recordId topic\n        if (topic) {\n            return this.client.realtime.unsubscribe(this.collectionIdOrName + \"/\" + topic);\n        }\n\n        // unsubscribe from everything related to the collection\n        return this.client.realtime.unsubscribeByPrefix(this.collectionIdOrName);\n    }\n\n    // ---------------------------------------------------------------\n    // Post update/delete AuthStore sync\n    // ---------------------------------------------------------------\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the updated id, then\n     * on success the `client.authStore.model` will be updated with the result.\n     */\n    update<T = Record>(id: string, bodyParams = {}, queryParams = {}): Promise<T> {\n        return super.update<Record>(id, bodyParams, queryParams).then((item) => {\n            if (\n                typeof this.client.authStore.model?.collectionId !== 'undefined' && // is record auth\n                this.client.authStore.model?.id === item?.id\n            ) {\n                this.client.authStore.save(this.client.authStore.token, item);\n            }\n\n            return item as any as T;\n        });\n    }\n\n    /**\n     * @inheritdoc\n     *\n     * If the current `client.authStore.model` matches with the deleted id,\n     * then on success the `client.authStore` will be cleared.\n     */\n    delete(id: string, queryParams = {}): Promise<boolean> {\n        return super.delete(id, queryParams).then((success) => {\n            if (\n                success &&\n                typeof this.client.authStore.model?.collectionId !== 'undefined' && // is record auth\n                this.client.authStore.model?.id === id\n            ) {\n                this.client.authStore.clear();\n            }\n\n            return success;\n        });\n    }\n\n    // ---------------------------------------------------------------\n    // Auth collection handlers\n    // ---------------------------------------------------------------\n\n    /**\n     * Prepare successful collection authorization response.\n     */\n    protected authResponse<T = Record>(responseData: any): RecordAuthResponse<T> {\n        const record = this.decode(responseData?.record || {});\n\n        this.client.authStore.save(responseData?.token, record);\n\n        return Object.assign({}, responseData, {\n            // normalize common fields\n            'token':  responseData?.token || '',\n            'record': record as any as T,\n        });\n    }\n\n    /**\n     * Returns all available collection auth methods.\n     */\n    listAuthMethods(queryParams = {}): Promise<AuthMethodsList> {\n        return this.client.send(this.baseCollectionPath + '/auth-methods', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            return Object.assign({}, responseData, {\n                // normalize common fields\n                'usernamePassword': !!responseData?.usernamePassword,\n                'emailPassword':    !!responseData?.emailPassword,\n                'authProviders':    Array.isArray(responseData?.authProviders) ? responseData?.authProviders : [],\n            });\n        });\n    }\n\n    /**\n     * Authenticate a single auth collection record via its username/email and password.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     */\n    authWithPassword<T = Record>(\n        usernameOrEmail: string,\n        password: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'identity': usernameOrEmail,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-password', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n            'headers': {\n                'Authorization': '',\n            },\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Authenticate a single auth collection record with OAuth2.\n     *\n     * On success, this method also automatically updates\n     * the client's AuthStore data and returns:\n     * - the authentication token\n     * - the authenticated record model\n     * - the OAuth2 account data (eg. name, email, avatar, etc.)\n     */\n    authWithOAuth2<T = Record>(\n        provider: string,\n        code: string,\n        codeVerifier: string,\n        redirectUrl: string,\n        createData = {},\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<RecordAuthResponse<T>> {\n        bodyParams = Object.assign({\n            'provider':     provider,\n            'code':         code,\n            'codeVerifier': codeVerifier,\n            'redirectUrl':  redirectUrl,\n            'createData':  createData,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/auth-with-oauth2', {\n            'method':  'POST',\n            'params':  queryParams,\n            'body':    bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Refreshes the current authenticated record instance and\n     * returns a new token and record data.\n     *\n     * On success this method also automatically updates the client's AuthStore.\n     */\n    authRefresh<T = Record>(bodyParams = {}, queryParams = {}): Promise<RecordAuthResponse<T>> {\n        return this.client.send(this.baseCollectionPath + '/auth-refresh', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then((data) => this.authResponse<T>(data));\n    }\n\n    /**\n     * Sends auth record password reset request.\n     */\n    requestPasswordReset(\n        email: string,\n        bodyParams  = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record password reset request.\n     */\n    confirmPasswordReset(\n        passwordResetToken: string,\n        password: string,\n        passwordConfirm: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token':           passwordResetToken,\n            'password':        password,\n            'passwordConfirm': passwordConfirm,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-password-reset', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends auth record verification email request.\n     */\n    requestVerification(\n        email: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'email': email,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record email verification request.\n     */\n    confirmVerification(\n        verificationToken: string,\n        bodyParams  = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': verificationToken,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-verification', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Sends an email change request to the authenticated record model.\n     */\n    requestEmailChange(\n        newEmail: string,\n        bodyParams = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'newEmail': newEmail,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/request-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Confirms auth record's new email address.\n     */\n    confirmEmailChange(\n        emailChangeToken: string,\n        password: string,\n        bodyParams  = {},\n        queryParams = {},\n    ): Promise<boolean> {\n        bodyParams = Object.assign({\n            'token': emailChangeToken,\n            'password': password,\n        }, bodyParams);\n\n        return this.client.send(this.baseCollectionPath + '/confirm-email-change', {\n            'method': 'POST',\n            'params': queryParams,\n            'body':   bodyParams,\n        }).then(() => true);\n    }\n\n    /**\n     * Lists all linked external auth providers for the specified auth record.\n     */\n    listExternalAuths(\n        recordId: string,\n        queryParams = {}\n    ): Promise<Array<ExternalAuth>> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData) => {\n            const items: Array<ExternalAuth> = [];\n\n            if (Array.isArray(responseData)) {\n                for (const item of responseData) {\n                    items.push(new ExternalAuth(item));\n                }\n            }\n\n            return items;\n        });\n    }\n\n    /**\n     * Unlink a single external auth provider from the specified auth record.\n     */\n    unlinkExternalAuth(\n        recordId: string,\n        provider: string,\n        queryParams = {}\n    ): Promise<boolean> {\n        return this.client.send(this.baseCrudPath + '/' + encodeURIComponent(recordId) + '/external-auths/' + encodeURIComponent(provider), {\n            'method': 'DELETE',\n            'params': queryParams,\n        }).then(() => true);\n    }\n}\n","import BaseModel   from '@/models/utils/BaseModel';\nimport SchemaField from '@/models/utils/SchemaField';\n\nexport default class Collection extends BaseModel {\n    name!:       string;\n    type!:       string;\n    schema!:     Array<SchemaField>;\n    system!:     boolean;\n    listRule!:   null|string;\n    viewRule!:   null|string;\n    createRule!: null|string;\n    updateRule!: null|string;\n    deleteRule!: null|string;\n    options!:    {[key:string]: any};\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        this.system    = !!data.system;\n        this.name      = typeof data.name    === 'string'    ? data.name    : '';\n        this.type      = typeof data.type    === 'string'    ? data.type    : 'base';\n        this.options   = typeof data.options !== 'undefined' ? data.options : {};\n\n        // rules\n        this.listRule   = typeof data.listRule   === 'string' ? data.listRule   : null;\n        this.viewRule   = typeof data.viewRule   === 'string' ? data.viewRule   : null;\n        this.createRule = typeof data.createRule === 'string' ? data.createRule : null;\n        this.updateRule = typeof data.updateRule === 'string' ? data.updateRule : null;\n        this.deleteRule = typeof data.deleteRule === 'string' ? data.deleteRule : null;\n\n        // schema\n        data.schema = Array.isArray(data.schema) ? data.schema : [];\n        this.schema = [];\n        for (let field of data.schema) {\n            this.schema.push(new SchemaField(field));\n        }\n    }\n\n    /**\n     * Checks if the current model is \"base\" collection.\n     */\n    get isBase(): boolean {\n        return this.type === 'base';\n    }\n\n    /**\n     * Checks if the current model is \"auth\" collection.\n     */\n    get isAuth(): boolean {\n        return this.type === 'auth';\n    }\n\n    /**\n     * Checks if the current model is \"single\" collection.\n     */\n    get isSingle(): boolean {\n        return this.type === 'single';\n    }\n}\n","import CrudService from '@/services/utils/CrudService';\nimport Collection  from '@/models/Collection';\n\nexport default class CollectionService extends CrudService<Collection> {\n    /**\n     * @inheritdoc\n     */\n    decode(data: { [key: string]: any }): Collection {\n        return new Collection(data);\n    }\n\n    /**\n     * @inheritdoc\n     */\n    get baseCrudPath(): string {\n        return '/api/collections';\n    }\n\n    /**\n     * Imports the provided collections.\n     *\n     * If `deleteMissing` is `true`, all local collections and schema fields,\n     * that are not present in the imported configuration, WILL BE DELETED\n     * (including their related records data)!\n     */\n    async import(collections: Array<Collection>, deleteMissing: boolean = false, queryParams = {}): Promise<true> {\n        return this.client.send(this.baseCrudPath + '/import', {\n            'method': 'PUT',\n            'params': queryParams,\n            'body': {\n                'collections':  collections,\n                'deleteMissing': deleteMissing,\n            }\n        }).then(() => true);\n    }\n}\n","import BaseModel from '@/models/utils/BaseModel';\n\nexport default class LogRequest extends BaseModel {\n    url!:       string;\n    method!:    string;\n    status!:    number;\n    auth!:      string;\n    remoteIp!:  string;\n    userIp!:    string;\n    referer!:   string;\n    userAgent!: string;\n    meta!:      { [key: string]: any };\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        super.load(data);\n\n        // fallback to the ip field for backward compatability\n        data.remoteIp = data.remoteIp || data.ip;\n\n        this.url       = typeof data.url       === 'string' ? data.url       : '';\n        this.method    = typeof data.method    === 'string' ? data.method    : 'GET';\n        this.status    = typeof data.status    === 'number' ? data.status    : 200;\n        this.auth      = typeof data.auth      === 'string' ? data.auth      : 'guest';\n        this.remoteIp  = typeof data.remoteIp  === 'string' ? data.remoteIp  : '';\n        this.userIp    = typeof data.userIp    === 'string' ? data.userIp    : '';\n        this.referer   = typeof data.referer   === 'string' ? data.referer   : '';\n        this.userAgent = typeof data.userAgent === 'string' ? data.userAgent : '';\n        this.meta      = typeof data.meta === 'object' && data.meta !== null ? data.meta : {};\n    }\n}\n","import LogRequest  from '@/models/LogRequest';\nimport ListResult  from '@/models/utils/ListResult';\nimport BaseService from '@/services/utils/BaseService';\n\nexport type HourlyStats = {\n    total: number,\n    date:  string,\n}\n\nexport default class LogService extends BaseService {\n    /**\n     * Returns paginated logged requests list.\n     */\n    getRequestsList(page = 1, perPage = 30, queryParams = {}): Promise<ListResult<LogRequest>> {\n        queryParams = Object.assign({\n            'page':    page,\n            'perPage': perPage,\n        }, queryParams);\n\n        return this.client.send('/api/logs/requests', {\n            'method': 'GET',\n            'params': queryParams,\n        }).then((responseData: any) => {\n            const items: Array<LogRequest> = [];\n            if (responseData?.items) {\n                responseData.items = responseData?.items || [];\n                for (const item of responseData.items) {\n                    items.push(new LogRequest(item));\n                }\n            }\n\n            return new ListResult<LogRequest>(\n                responseData?.page || 1,\n                responseData?.perPage || 0,\n                responseData?.totalItems || 0,\n                responseData?.totalPages || 0,\n                items,\n            );\n        });\n    }\n\n    /**\n     * Returns a single logged request by its id.\n     */\n    getRequest(id: string, queryParams = {}): Promise<LogRequest> {\n        return this.client.send('/api/logs/requests/' + encodeURIComponent(id), {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => new LogRequest(responseData));\n    }\n\n    /**\n     * Returns request logs statistics.\n     */\n    getRequestsStats(queryParams = {}): Promise<Array<HourlyStats>> {\n        return this.client.send('/api/logs/requests/stats', {\n            'method': 'GET',\n            'params': queryParams\n        }).then((responseData: any) => responseData);\n    }\n}\n","import BaseService from '@/services/utils/BaseService';\n\nexport type UnsubscribeFunc = () => Promise<void>;\n\nexport default class RealtimeService extends BaseService {\n    private clientId: string = \"\";\n    private eventSource: EventSource | null = null;\n    private subscriptions: { [key: string]: Array<EventListener> } = {};\n\n    /**\n     * Register the subscription listener.\n     *\n     * You can subscribe multiple times to the same topic.\n     *\n     * If the SSE connection is not started yet,\n     * this method will also initialize it.\n     */\n    async subscribe(topic: string, callback: (data: any) => void): Promise<UnsubscribeFunc> {\n        if (!topic) {\n            throw new Error('topic must be set.')\n        }\n\n        const listener = function (e: Event) {\n            const msgEvent = (e as MessageEvent);\n\n            let data;\n            try {\n                data = JSON.parse(msgEvent?.data);\n            } catch {}\n\n            callback(data || {});\n        };\n\n        // store the listener\n        if (!this.subscriptions[topic]) {\n            this.subscriptions[topic] = [];\n        }\n        this.subscriptions[topic].push(listener);\n\n        if (!this.eventSource) {\n            // start a new sse connection\n            this.connect();\n        } else if (this.subscriptions[topic].length === 1) {\n            // send the updated subscriptions (if it is the first for the topic)\n            await this.submitSubscriptions();\n        } else {\n            // only register the listener\n            this.eventSource.addEventListener(topic, listener);\n        }\n\n        return async (): Promise<void> => {\n            return this.unsubscribeByTopicAndListener(topic, listener);\n        };\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners with the specified topic.\n     *\n     * If `topic` is not provided, then this method will unsubscribe\n     * from all active subscriptions.\n     *\n     * This method is no-op if there are no active subscriptions.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribe(topic?: string): Promise<void> {\n        if (!this.hasSubscriptionListeners(topic)) {\n            return; // already unsubscribed\n        }\n\n        if (!topic) {\n            // remove all subscriptions\n            this.subscriptions = {};\n        } else {\n            // remove all topic listeners\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscription listeners starting with the specified topic prefix.\n     *\n     * This method is no-op if there are no active subscriptions with the specified topic prefix.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByPrefix(topicPrefix: string): Promise<void> {\n        let hasAtleastOneTopic = false;\n        for (let topic in this.subscriptions) {\n            if (!topic.startsWith(topicPrefix)) {\n                continue;\n            }\n\n            hasAtleastOneTopic = true;\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource?.removeEventListener(topic, listener);\n            }\n            delete this.subscriptions[topic];\n        }\n\n        if (!hasAtleastOneTopic) {\n            return; // nothing to unsubscribe from\n        }\n\n        if (this.hasSubscriptionListeners()) {\n            // submit the deleted subscriptions\n            await this.submitSubscriptions();\n        } else {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        }\n    }\n\n    /**\n     * Unsubscribe from all subscriptions matching the specified topic and listener function.\n     *\n     * This method is no-op if there are no active subscription with\n     * the specified topic and listener.\n     *\n     * The related sse connection will be autoclosed if after the\n     * unsubscribe operation there are no active subscriptions left.\n     */\n    async unsubscribeByTopicAndListener(topic: string, listener: EventListener): Promise<void> {\n        if (!Array.isArray(this.subscriptions[topic]) || !this.subscriptions[topic].length) {\n            return; // already unsubscribed\n        }\n\n        let exist = false;\n        for (let i = this.subscriptions[topic].length - 1; i >= 0; i--) {\n            if (this.subscriptions[topic][i] !== listener) {\n                continue;\n            }\n\n            exist = true;                           // has at least one matching listener\n            delete this.subscriptions[topic][i];    // removes the function reference\n            this.subscriptions[topic].splice(i, 1); // reindex the array\n            this.eventSource?.removeEventListener(topic, listener);\n        }\n        if (!exist) {\n            return;\n        }\n\n        // remove the topic from the subscriptions list if there are no other listeners\n        if (!this.subscriptions[topic].length) {\n            delete this.subscriptions[topic];\n        }\n\n        if (!this.hasSubscriptionListeners()) {\n            // no other active subscriptions -> close the sse connection\n            this.disconnect();\n        } else if (!this.hasSubscriptionListeners(topic)) {\n            // submit subscriptions change if there are no other active subscriptions related to the topic\n            await this.submitSubscriptions();\n        }\n    }\n\n    private hasSubscriptionListeners(topicToCheck?: string): boolean {\n        this.subscriptions = this.subscriptions || {};\n\n        // check the specified topic\n        if (topicToCheck) {\n            return !!this.subscriptions[topicToCheck]?.length;\n        }\n\n        // check for at least one non-empty topic\n        for (let topic in this.subscriptions) {\n            if (!!this.subscriptions[topic]?.length) {\n                return true\n            }\n        }\n\n        return false;\n    }\n\n    private async submitSubscriptions(): Promise<boolean> {\n        if (!this.clientId) {\n            return false;\n        }\n\n        // optimistic update\n        this.addAllSubscriptionListeners();\n\n        return this.client.send('/api/realtime', {\n            'method': 'POST',\n            'body': {\n                'clientId': this.clientId,\n                'subscriptions': this.getNonEmptySubscriptionTopics(),\n            },\n            'params': {\n                '$cancelKey': \"realtime_subscriptions_\" + this.clientId,\n            },\n        }).then(() => true).catch((err) => {\n            if (err?.isAbort) {\n                return true; // silently ignore aborted pending requests\n            }\n            throw err;\n        });\n    }\n\n    private getNonEmptySubscriptionTopics(): Array<string> {\n        const result : Array<string> = [];\n\n        for (let topic in this.subscriptions) {\n            if (this.subscriptions[topic].length) {\n                result.push(topic);\n            }\n        }\n\n        return result;\n    }\n\n    private addAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        this.removeAllSubscriptionListeners();\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.addEventListener(topic, listener);\n            }\n        }\n    }\n\n    private removeAllSubscriptionListeners(): void {\n        if (!this.eventSource) {\n            return;\n        }\n\n        for (let topic in this.subscriptions) {\n            for (let listener of this.subscriptions[topic]) {\n                this.eventSource.removeEventListener(topic, listener);\n            }\n        }\n    }\n\n    private connectHandler(e: Event): void {\n        const msgEvent = (e as MessageEvent);\n        this.clientId = msgEvent?.lastEventId;\n        this.submitSubscriptions();\n    }\n\n    private connect(): void {\n        this.disconnect();\n        this.eventSource = new EventSource(this.client.buildUrl('/api/realtime'))\n        this.eventSource.addEventListener('PB_CONNECT', (e) => this.connectHandler(e));\n    }\n\n    private disconnect(): void {\n        this.removeAllSubscriptionListeners();\n        this.eventSource?.removeEventListener('PB_CONNECT', (e) => this.connectHandler(e));\n        this.eventSource?.close();\n        this.eventSource = null;\n        this.clientId = \"\";\n    }\n}\n","import ClientResponseError from \"@/ClientResponseError\";\nimport BaseAuthStore from \"@/stores/BaseAuthStore\";\nimport LocalAuthStore from \"@/stores/LocalAuthStore\";\nimport ViewService from \"./services/ViewService\";\nimport SettingsService from \"@/services/SettingsService\";\nimport AdminService from \"@/services/AdminService\";\nimport RecordService from \"@/services/RecordService\";\nimport CollectionService from \"@/services/CollectionService\";\nimport LogService from \"@/services/LogService\";\nimport RealtimeService from \"@/services/RealtimeService\";\nimport Record from \"@/models/Record\";\n\n/**\n * PocketBase JS Client.\n */\nexport default class Client {\n  /**\n   * The base PocketBase backend url address (eg. 'http://127.0.0.1.8090').\n   */\n  baseUrl: string;\n\n  /**\n   * Hook that get triggered right before sending the fetch request,\n   * allowing you to inspect/modify the request config.\n   *\n   * Returns the new modified config that will be used to send the request.\n   *\n   * For list of the possible options check https://developer.mozilla.org/en-US/docs/Web/API/fetch#options\n   *\n   * Example:\n   * ```js\n   * client.beforeSend = function (url, reqConfig) {\n   *     reqConfig.headers = Object.assign({}, reqConfig.headers, {\n   *         'X-Custom-Header': 'example',\n   *     });\n   *\n   *     return reqConfig;\n   * };\n   * ```\n   */\n  beforeSend?: (\n    url: string,\n    reqConfig: { [key: string]: any }\n  ) => { [key: string]: any };\n\n  /**\n   * Hook that get triggered after successfully sending the fetch request,\n   * allowing you to inspect/modify the response object and its parsed data.\n   *\n   * Returns the new Promise resolved `data` that will be returned to the client.\n   *\n   * Example:\n   * ```js\n   * client.afterSend = function (response, data) {\n   *     if (response.status != 200) {\n   *         throw new ClientResponseError({\n   *             url:      response.url,\n   *             status:   response.status,\n   *             data:     data,\n   *         });\n   *     }\n   *\n   *     return data;\n   * };\n   * ```\n   */\n  afterSend?: (response: Response, data: any) => any;\n\n  /**\n   * Optional language code (default to `en-US`) that will be sent\n   * with the requests to the server as `Accept-Language` header.\n   */\n  lang: string;\n\n  /**\n   * A replaceable instance of the local auth store service.\n   */\n  authStore: BaseAuthStore;\n\n  /**\n   * An instance of the service that handles the **Settings APIs**.\n   */\n  readonly settings: SettingsService;\n\n  /**\n   * An instance of the service that handles the **Admin APIs**.\n   */\n  readonly admins: AdminService;\n\n  /**\n   * An instance of the service that handles the **Collection APIs**.\n   */\n  readonly collections: CollectionService;\n\n  readonly views: ViewService;\n\n  /**\n   * An instance of the service that handles the **Record APIs**.\n   */\n\n  /**\n   * An instance of the service that handles the **Log APIs**.\n   */\n  readonly logs: LogService;\n\n  /**\n   * An instance of the service that handles the **Realtime APIs**.\n   */\n  readonly realtime: RealtimeService;\n\n  private cancelControllers: { [key: string]: AbortController } = {};\n  private recordServices: { [key: string]: RecordService } = {};\n  private enableAutoCancellation: boolean = true;\n\n  constructor(baseUrl = \"/\", authStore?: BaseAuthStore | null, lang = \"en-US\") {\n    this.baseUrl = baseUrl;\n    this.lang = lang;\n    this.authStore = authStore || new LocalAuthStore();\n\n    // services\n    this.views = new ViewService(this);\n    this.admins = new AdminService(this);\n    this.collections = new CollectionService(this);\n    this.logs = new LogService(this);\n    this.settings = new SettingsService(this);\n    this.realtime = new RealtimeService(this);\n  }\n\n  /**\n   * Returns the RecordService associated to the specified collection.\n   *\n   * @param  {string} idOrName\n   * @return {RecordService}\n   */\n  collection(idOrName: string): RecordService {\n    if (!this.recordServices[idOrName]) {\n      this.recordServices[idOrName] = new RecordService(this, idOrName);\n    }\n\n    return this.recordServices[idOrName];\n  }\n\n  /**\n   * Globally enable or disable auto cancellation for pending duplicated requests.\n   */\n  autoCancellation(enable: boolean): Client {\n    this.enableAutoCancellation = !!enable;\n\n    return this;\n  }\n\n  /**\n   * Cancels single request by its cancellation key.\n   */\n  cancelRequest(cancelKey: string): Client {\n    if (this.cancelControllers[cancelKey]) {\n      this.cancelControllers[cancelKey].abort();\n      delete this.cancelControllers[cancelKey];\n    }\n\n    return this;\n  }\n\n  /**\n   * Cancels all pending requests.\n   */\n  cancelAllRequests(): Client {\n    for (let k in this.cancelControllers) {\n      this.cancelControllers[k].abort();\n    }\n\n    this.cancelControllers = {};\n\n    return this;\n  }\n\n  /**\n   * Sends an api http request.\n   */\n  async send(path: string, reqConfig: { [key: string]: any }): Promise<any> {\n    let config = Object.assign(\n      { method: \"GET\" } as { [key: string]: any },\n      reqConfig\n    );\n\n    // serialize the body if needed and set the correct content type\n    // note1: for FormData body the Content-Type header should be skipped\n    // note2: we are checking the constructor name because FormData is not available natively in node\n    if (config.body && config.body.constructor.name !== \"FormData\") {\n      if (typeof config.body !== \"string\") {\n        config.body = JSON.stringify(config.body);\n      }\n\n      // add the json header (if not already)\n      if (typeof config?.headers?.[\"Content-Type\"] === \"undefined\") {\n        config.headers = Object.assign({}, config.headers, {\n          \"Content-Type\": \"application/json\",\n        });\n      }\n    }\n\n    // add Accept-Language header (if not already)\n    if (typeof config?.headers?.[\"Accept-Language\"] === \"undefined\") {\n      config.headers = Object.assign({}, config.headers, {\n        \"Accept-Language\": this.lang,\n      });\n    }\n\n    // check if Authorization header can be added\n    if (\n      // has stored token\n      this.authStore?.token &&\n      // auth header is not explicitly set\n      typeof config?.headers?.Authorization === \"undefined\"\n    ) {\n      config.headers = Object.assign({}, config.headers, {\n        Authorization: this.authStore.token,\n      });\n    }\n\n    // handle auto cancelation for duplicated pending request\n    if (this.enableAutoCancellation && config.params?.$autoCancel !== false) {\n      const cancelKey =\n        config.params?.$cancelKey || (config.method || \"GET\") + path;\n\n      // cancel previous pending requests\n      this.cancelRequest(cancelKey);\n\n      const controller = new AbortController();\n      this.cancelControllers[cancelKey] = controller;\n      config.signal = controller.signal;\n    }\n    // remove the special cancellation params from the other valid query params\n    delete config.params?.$autoCancel;\n    delete config.params?.$cancelKey;\n\n    // build url + path\n    let url = this.buildUrl(path);\n\n    // serialize the query parameters\n    if (typeof config.params !== \"undefined\") {\n      const query = this.serializeQueryParams(config.params);\n      if (query) {\n        url += (url.includes(\"?\") ? \"&\" : \"?\") + query;\n      }\n      delete config.params;\n    }\n\n    if (this.beforeSend) {\n      config = Object.assign({}, this.beforeSend(url, config));\n    }\n\n    // send the request\n    return fetch(url, config)\n      .then(async (response) => {\n        let data: any = {};\n\n        try {\n          data = await response.json();\n        } catch (_) {\n          // all api responses are expected to return json\n          // with the exception of the realtime event and 204\n        }\n\n        if (this.afterSend) {\n          data = this.afterSend(response, data);\n        }\n\n        if (response.status >= 400) {\n          throw new ClientResponseError({\n            url: response.url,\n            status: response.status,\n            data: data,\n          });\n        }\n\n        return data;\n      })\n      .catch((err) => {\n        // wrap to normalize all errors\n        throw new ClientResponseError(err);\n      });\n  }\n\n  /**\n   * Builds and returns an absolute record file url for the provided filename.\n   */\n  getFileUrl(record: Record, filename: string, queryParams = {}): string {\n    const parts = [];\n    parts.push(\"api\");\n    parts.push(\"files\");\n    parts.push(\n      encodeURIComponent(record.collectionId || record.collectionName)\n    );\n    parts.push(encodeURIComponent(record.id));\n    parts.push(encodeURIComponent(filename));\n\n    let result = this.buildUrl(parts.join(\"/\"));\n\n    if (Object.keys(queryParams).length) {\n      const params = new URLSearchParams(queryParams);\n      result += (result.includes(\"?\") ? \"&\" : \"?\") + params;\n    }\n\n    return result;\n  }\n\n  /**\n   * Builds a full client url by safely concatenating the provided path.\n   */\n  buildUrl(path: string): string {\n    let url = this.baseUrl + (this.baseUrl.endsWith(\"/\") ? \"\" : \"/\");\n    if (path) {\n      url += path.startsWith(\"/\") ? path.substring(1) : path;\n    }\n    return url;\n  }\n\n  /**\n   * Serializes the provided query parameters into a query string.\n   */\n  private serializeQueryParams(params: { [key: string]: any }): string {\n    const result: Array<string> = [];\n    for (const key in params) {\n      if (params[key] === null) {\n        // skip null query params\n        continue;\n      }\n\n      const value = params[key];\n      const encodedKey = encodeURIComponent(key);\n\n      if (Array.isArray(value)) {\n        // \"repeat\" array params\n        for (const v of value) {\n          result.push(encodedKey + \"=\" + encodeURIComponent(v));\n        }\n      } else if (value instanceof Date) {\n        result.push(encodedKey + \"=\" + encodeURIComponent(value.toISOString()));\n      } else if (typeof value !== null && typeof value === \"object\") {\n        result.push(\n          encodedKey + \"=\" + encodeURIComponent(JSON.stringify(value))\n        );\n      } else {\n        result.push(encodedKey + \"=\" + encodeURIComponent(value));\n      }\n    }\n\n    return result.join(\"&\");\n  }\n}\n","\nexport default class ViewRecord {\n    constructor(data: { [key: string]: any } = {}) {\n        this.load(data || {});\n    }\n\n    [key: string]: any,\n\n    /**\n     * @inheritdoc\n     */\n    load(data: { [key: string]: any }) {\n        for (const [key, value] of Object.entries(data)) {\n            this[key] = value;\n        }\n    }\n    clone(): ViewRecord {\n        return new (this.constructor as any)(JSON.parse(JSON.stringify(this)));\n    }\n\n    /**\n     * Exports all model properties as a new plain object.\n     */\n    export(): { [key: string]: any } {\n        return Object.assign({}, this);\n    }\n}\n"],"names":["atobPolyfill","ClientResponseError","_super","errData","_this","this","call","url","status","data","isAbort","originalError","Object","setPrototypeOf","prototype","DOMException","name","message","_a","__extends","toJSON","__assign","Error","fieldContentRegExp","cookieSerialize","val","options","opt","assign","encode","defaultEncode","test","TypeError","value","result","maxAge","isNaN","isFinite","Math","floor","domain","path","expires","toString","Date","isDate","valueOf","toUTCString","httpOnly","secure","priority","toLowerCase","sameSite","defaultDecode","indexOf","decodeURIComponent","encodeURIComponent","getTokenPayload","token","encodedPayload","split","map","c","charCodeAt","slice","join","JSON","parse","e","atob","input","str","String","replace","length","bs","buffer","bc","idx","output","charAt","fromCharCode","BaseModel","load","_i","entries","_b","key","id","created","updated","defineProperty","get","clone","constructor","stringify","export","Record","collectionId","collectionName","expand","Admin","avatar","email","BaseAuthStore","baseToken","baseModel","_onChangeCallbacks","expirationThreshold","payload","keys","exp","now","isTokenExpired","save","model","triggerChange","clear","loadFromCookie","cookie","rawData","decode","index","eqIdx","endIdx","lastIndexOf","trim","undefined","_","cookieParse","Array","isArray","exportToCookie","defaultOptions","resultLength","Blob","size","_c","username","verified","onChange","callback","fireImmediately","push","i","splice","LocalAuthStore","storageKey","storageFallback","_storageGet","_storageSet","_storageRemove","window","localStorage","rawValue","getItem","normalizedVal","setItem","removeItem","ListResult","page","perPage","totalItems","totalPages","items","BaseService","client","CrudService","getFullList","batch","queryParams","_getFullList","baseCrudPath","getList","_getList","getFirstListItem","filter","_getFirstListItem","getOne","_getOne","create","bodyParams","_create","update","_update","delete","_delete","BaseCrudService","basePath","batchSize","request","__awaiter","then","list","castedList","concat","send","method","params","responseData","item","$cancelKey","code","body","SchemaField","type","system","required","unique","ViewService","listRule","sql","schema","field","Views","getRecordsFullList","viewName","getRecordsList","console","log","ViewRecord","ViewRecordListResult","SettingsService","getAll","testS3","testEmail","toEmail","emailTemplate","template","AdminService","authStore","success","authResponse","admin","authWithPassword","password","identity","headers","Authorization","bind","authRefresh","requestPasswordReset","confirmPasswordReset","passwordResetToken","passwordConfirm","ExternalAuth","recordId","provider","providerId","RecordService","collectionIdOrName","baseCollectionPath","subscribeOne","warn","realtime","subscribe","topicOrCallback","topic","unsubscribe","unsubscribeByPrefix","record","listAuthMethods","usernamePassword","emailPassword","authProviders","usernameOrEmail","authWithOAuth2","codeVerifier","redirectUrl","createData","requestVerification","confirmVerification","verificationToken","requestEmailChange","newEmail","confirmEmailChange","emailChangeToken","listExternalAuths","responseData_1","unlinkExternalAuth","Collection","viewRule","createRule","updateRule","deleteRule","CollectionService","import","collections","deleteMissing","LogRequest","remoteIp","ip","auth","userIp","referer","userAgent","meta","LogService","getRequestsList","getRequest","getRequestsStats","RealtimeService","apply","arguments","clientId","eventSource","subscriptions","listener","msgEvent","connect","submitSubscriptions","sent","addEventListener","unsubscribeByTopicAndListener","hasSubscriptionListeners","removeEventListener","disconnect","topicPrefix","hasAtleastOneTopic","startsWith","exist","topicToCheck","addAllSubscriptionListeners","getNonEmptySubscriptionTopics","catch","err","removeAllSubscriptionListeners","connectHandler","lastEventId","EventSource","buildUrl","close","Client","baseUrl","lang","cancelControllers","recordServices","enableAutoCancellation","views","admins","logs","settings","collection","idOrName","autoCancellation","enable","cancelRequest","cancelKey","abort","cancelAllRequests","k","reqConfig","config","_d","_e","$autoCancel","_f","controller","AbortController","signal","_g","_h","query","serializeQueryParams","includes","beforeSend","fetch","response","json","afterSend","getFileUrl","filename","parts","URLSearchParams","endsWith","substring","encodedKey","value_1","v","toISOString"],"mappings":"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"}